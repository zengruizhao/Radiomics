//////////////////////////////////////////////////////////////////////////////////////////

// ccipd includes
#include "ccipdBoundingBoxCoordinates.h"
#include "ccipdBoundingBoxCreation.h"
#include "ccipdBoundingBoxToActor.h" // for bounding box rendering
#include "ccipdCohenMRIBiasCorrection.h"
#include "ccipdCropImage.h"
#include "ccipdDisplayStatusMessage.h"
#include "ccipdDuplicateImage.h"
#include "ccipdExtractFeatureImage.hxx"
#include "ccipdFeatureCollection.h"
#include "ccipdFeatureID.h"
#include "ccipdFeatureTypes.h"
#include "ccipdFileTypes.h"
#include "ccipdFlipImage.h"
#include "ccipdGetLargestContiguousRegion.h"
#include "ccipdHistogram.h"
#include "ccipdImageToProp.hxx"
#include "ccipdInsertImage.h"
#include "ccipdIsosurfaceRendering.h"
#include "ccipdLandmarksToActor.h"
#include "ccipdLDAClassifier.h" 
#include "ccipdLevelsetToSurface.h"
#include "ccipdLoadableFactory.h"
#include "ccipdLoadImage.h"
#include "ccipdLoadMRI.h"
#include "ccipdLoadVolume.h"
#include "ccipdMaskImage.h"
#include "ccipdMaskPixelValue.h"
#include "ccipdMatrixUtils.h"
#include "ccipdPickPointsOnVolume.h"
#include "ccipdPrepareClassificationData.h"
#include "ccipdPreprocessT2.h"
#include "ccipdPreprocessVolume.h"
#include "ccipdProstaCADMainWindow.h"
#include "ccipdQDAClassifier.h" 
#include "ccipdResizeImage.h"
#include "ccipdSaveGUI.h"
#include "ccipdSaveImage.h"
#include "ccipdSaveImageGUI.h"
#include "ccipdSetChannelByIndex.h"
#include "ccipdStandardizeImage.h"
#include "ccipdStatistics.h"
#include "ccipdStudy.h"
#include "ccipdTextureFeatureFirstOrderParameters.h"
#include "ccipdTextureFeatureGaborParameters.h"
#include "ccipdTextureFeatureHaralickParameters.h"
#include "ccipdTextureFeatureMapParametersType.h"  
#include "ccipdTextureFeatureParser.h"
#include "ccipdUpdateSlicesSliders.h"
#include "ccipdUpdateVTKImageProp.h"
#include "ccipdUpdateVTKImageSlice.h"
#include "ccipdUpdateVTKImageWindowLevel.h"
#include "ccipdUpdateVTKPropColor.h"
#include "ccipdUpdateVTKPropTransparency.h"
#include "ccipdUpdateWindowLevelSliders.h"
#include "ccipdVolumeContainerToVolumeFeatures.h"
#include "ccipdVolumeTypes.h"
//#include "ccipdVTKForwardDeclarations.h"
#include "ccipdVTKUtils.h"
#include "ccipdWriteImage.h"

#include "ccipdDisableWarningsMacro.h"

// Qt includes
#include <QApplication>
#include <QMessageBox>
#include <QFileDialog>
#include "ui_ccipdProstaCADMainWindow.h"
#include <QSettings>
#include <QMouseEvent>
#include <QLabel>
#include <QTimer>
#include <QSlider>

// itk includes
#include "itkDCEFeaturesFilter.h"
#include "itkDCEMaxFilter.h"
#include "itkDCEMinFilter.h"
#include "itkDCEMeanFilter.h"
#include "itkDCEMedianFilter.h"
#include "itkDCESumFilter.h"
#include "itkDCEStdDevFilter.h"
#include "itkDCEVarianceFilter.h"
#include <itkImage.h>
//#include <itkImageIterator.h>
#include <itkRGBAPixel.h>
#include <itkRGBPixel.h>
#include <itkVectorImage.h>

// vtk includes
#include <vtkActor.h>
//#include <vtkImageActor.h>
#include <vtkProp.h>
//#include <vtkProperty.h>
#include <vtkRenderer.h>
#include <vtkRenderWindow.h>
//#include <vtkRenderWindowInteractor.h>
#include <vtkSmartPointer.h>
//#include <vtkVolumeProperty.h>


// std includes
//#include <math.h>
#include <iostream>

// third party includes
#include "SimpleINI.h"

#include "ccipdEnableWarningsMacro.h"

///////////

//////////////////////////////////////////////////////////////////////////////////////////
using namespace std;
//////////////////////////////////////////////////////////////////////////////////////////

namespace ccipd
{

//////////////////////////////////////////////////////////////////////////////////////////
/// PIMPL Interface to ProstaCADMainWindow
class ProstaCADMainWindow::SecretData : boost::noncopyable
{

public:
  SecretData(); ///< Constructor

  QSettings m_settings;

  QString m_lastOriginalVolumePath;

  QString m_lastVolumePath_DCE;

  QString m_lastProstateMaskPath;
  QString m_lastHeatmapPath;
  QString m_lastprobabilitiesImagePath;
  QString m_lastImagePath;
  QString m_lastAppSnapshotPath;


  QStringList requested_DCE_Features;


  bool                    m_bVerbose, m_bCurrentlyInitializingGUI;
  VolumeImagePointer      m_pOriginalVolume, m_pPreprocessedVolume, m_pCurrentFeatureVolume
	                      , m_pCurrentDCEVolume, m_pCurrentDCEFeature
						            ;
  VolumeVectorPointer     m_pVolume_DCE, m_pPreprocessedVolume_DCE;


  VolumeImageType::RegionType        croppingBoundingBox;
  VolumeVectorType::SizeType   m_cropSize_DCE; // holds the number of pixels to be cut from the image borders



  VolumeImagePointer      m_pRefVolume;



  VolumeImagePointer      m_pProbabilitiesImage; // This will hold the output of classification (probabilities for either cancer or not in whole prostate)
  RGBAVolumePointer       m_pHeatMap;
  
  VolumeMaskImagePointer m_pProstateMask;
  VolumeMaskImagePointer m_pPZMask;
  VolumeMaskImagePointer m_pCGMask;

   // For Volumes as Slices
   vtkPropPointer	m_ImageProp_T2	          /*< Store the vtk prop for the originally loaded image */
                  , m_PreprocessedImageProp
                  , m_ProstateMaskProp
                  , m_PZMaskProp
                  , m_CGMaskProp
                  , m_HeatmapProp 
                  , m_CurrentFeatureImageProp
                  , m_ImageProp_DCE                // This corresponds to the m_pCurrentDCEVolume
                  , m_ImageProp_DCE_Features       // This corresponds to the m_pCurrentDCEFeature
//  			  , m_FixedCorrectionPointsProp
                  ;


  // For Surfaces
	vtkActorPointer   m_pProstateLevelsetSurfaceActor
                    , m_pPZLevelsetSurfaceActor
                    , m_pCGLevelsetSurfaceActor
                    , m_pCancerLevelsetSurfaceActor
                    ;


  //vtkImageViewer2*              m_pViewer; // The whole volume lies here
 
/////////////////////////////////////////////
  ////////////////////////////////////////////
  ///////////FEATURE EXTRACTION///////////////
  FeatureIDCollection           m_FeatureIDs;          // List of Texture Features 
  FeatureCollectionPointer      m_pFeatureCollection;  // Holding data about extracted features
  VolumeFeaturesConstPointer    m_pFeatureVectorImage; // Holds the the vector image resulting from calculating features
  vector<vector<unsigned int>>  m_FeaturesHierarchy  ; // This holds the numbers of subfeatures in each feature
 

  VolumeFeaturesPointer m_pVectorImage_DCE_Features;


/////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// Classification
  ccipdLDAClassifier      m_LDAclassifier;
  ccipdQDAClassifier      m_QDAClassifier;
  double                  m_LevelSetValue;
/////////////////////////////////////////////////////////
  float            m_HeatMapRange;   // This is the min probability (which will bear the red color) in the heat map, its default value is 1
  float            m_HeatmapMinimum; // This is the max probability which will be colored blue in the heat map, all values less than this value will all be colored blue too.
  
  
  unsigned int m_currentSlice,  m_currentSlicePreprocessed, m_currentSliceCurrentFeature;   // Number of slice (zero-based) shown in the viewer
  unsigned int m_currentSliceNum_DCE, m_currentTimePointIndex_DCE, m_currentSliceNum_DCE_Features;


  bool m_bWhitenData;

  HistogramDPointer m_pReferenceHistogram;



////////////////////////////////////////////////////////////////////
  ////////////////////QSETTINGS/////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////
  
  // Application Settings
  bool m_bFirstTimeOperation;
  
  // Preprocessing Options
  // Bias Field Correction
    bool m_bCorrectForBiasField, m_bUseCohenBFC;
    double m_sigmaBFC;
  
  // Standardization
    bool m_bStandardize, m_bUseRefHistogram;              
    unsigned int m_RefHistogramBinsNum, m_RefHistogramMatchingPtsNum;
    QString m_RefHistogramFilePath, m_RefVolumeImageFilePath;  

  // Cropping
    bool m_bCropOriginalVolume, m_bCropAutomatically;
    double m_CroppingPadding;
	 
  // Normalization
    bool m_bNormalizeOriginalVolume;

//////////////////////////////////////////////////////////////////////////

}; // class SecretData
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
ProstaCADMainWindow::SecretData::SecretData()
{
	
	m_bVerbose = true;
	m_bCurrentlyInitializingGUI = false;
//////////////////////////////////////////////////////////////////////////
  m_pFeatureCollection  = FeatureCollection   ::New();

  m_currentSliceNum_DCE = 0;
  m_currentTimePointIndex_DCE = 0;
  m_currentSliceNum_DCE_Features = 0;

  m_cropSize_DCE.Fill(0);

} // constructor
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
ProstaCADMainWindow::ProstaCADMainWindow() : ccipdNewPIMPLMacro
{
	RetrieveSettings();
   
	initGUI();


	// init : General for other non-GUI objects






// Load Classification Settings

  THIS->m_LevelSetValue = 0.5;
  THIS->m_HeatMapRange = 1.00f;
  THIS->m_HeatmapMinimum = 0.00f;
  THIS->m_bWhitenData = true;
  


  //// VTK Renderer
  //const vtkRendererPointer renderer = vtkRendererPointer::New();
  //renderer->SetBackground( 1.00, 1.00, 1.00);

  //// create an interactor style
  //const vtkInteractorStylePointer interactorStyle = vtkInteractorStyleTrackballCameraPointer::New();

  //// get the render window
  //const vtkRenderWindowPointer renderWindow = ui->qVTKWidget_Volume->GetRenderWindow();
 
  // // make sure we have an interactor
  // vtkRenderWindowInteractorPointer interactor = renderWindow->GetInteractor();
  // if (!interactor)
  // {
 	//	interactor = vtkRenderWindowInteractorPointer::New();
 	//	interactor->SetRenderWindow( renderWindow );
  // } // !interactor
 
  // // update the style
  // renderWindow->GetInteractor()->SetInteractorStyle(interactorStyle);
 
  // // add the renderer
  // renderWindow->AddRenderer( renderer );
 
  // renderWindow->Render();





   
   // Training the class
   //For Testing purposes

   //EigenMatrixTypeF trainingSet((uint)9, (uint)2);
   //trainingSet << 8,7,4,2,2,4,2,3,4,4,9,10,6,8,9,5,10,8;
   //EigenLabelVector group((uint)9);
   //group << 2, 1, 1, 1, 1, 2, 2, 2, 2;//, 2, 1, 1, 1, 1, 2, 2, 2, 2;
   ////ccipdLDAClassifier THIS->m_LDAclassifier;
   //THIS->m_LDAclassifier.Train(trainingSet, group);
   
   
   EigenVectorTypeD probl(2);
   EigenVectorTypeD logdetSigmal(1);
   EigenMatrixTypeD Rl(50, 50);
   EigenMatrixTypeD gmeansl(2, 50);

   probl << 0.5, 0.5;
   logdetSigmal << 16.576378212484870;
   Rl <<-2.066709, -0.491517, -2.735259, -2.188762, -1.889005, -1.857954, -2.034370, -2.054330, -2.092334, -2.353009, -1.040113, -0.966053, -1.036019, -1.343567, -1.724301, -1.576138, -1.234968, -1.123268, -0.933127, -0.889832, -0.986877, -1.272452, -1.576840, -1.473537, -1.168725, -1.039600, -0.796433, -0.783423, -0.886872, -1.109174, -1.353966, -1.298852, -1.032410, -0.902544, -0.625965, -0.614426, -0.620654, -0.766638, -1.025081, -0.880633, -0.701160, -0.673102, -0.316382, -0.330032, -0.347587, -0.504297, -0.656330, -0.643453, -0.441412, -0.364261, 0.000000, 1.273986, -0.807115, -0.447937, -0.358519, -0.120522, -0.089398, -0.121316, -0.331152, -0.437223, 0.132106, 0.129242, 0.185116, 0.311139, 0.356314, 0.318341, 0.224323, 0.147540, 0.247486, 0.239597, 0.279301, 0.398010, 0.439402, 0.417986, 0.346279, 0.269604, 0.318725, 0.291025, 0.341646, 0.455721, 0.495369, 0.511764, 0.418377, 0.337741, 0.395606, 0.412793, 0.433051, 0.596649, 0.822521, 0.724645, 0.471315, 0.426322, 0.408639, 0.425294, 0.370636, 0.613188, 0.813359, 0.745600, 0.450822, 0.408567, 0.000000, 0.000000, -4.726641, -2.569814, -0.922045, -0.167744, 0.188756, -0.231837, -0.933743, -2.739463, -1.002948, -0.486068, 0.036452, 0.292713, 0.437624, 0.245078, -0.019395, -0.609686, -0.592620, -0.270070, 0.098404, 0.301435, 0.415479, 0.260188, 0.038622, -0.360782, -0.463082, -0.211914, 0.091179, 0.269676, 0.346744, 0.229341, 0.040299, -0.280961, -0.431864, -0.232608, 0.012993, 0.174376, 0.250086, 0.139062, -0.023339, -0.298157, -0.281987, -0.224599, -0.065533, 0.069730, 0.116610, 0.035998, -0.080724, -0.229343, 0.000000, 0.000000, 0.000000, -2.377897, -1.581881, -0.366253, -0.104577, -0.300202, -0.267897, 0.301631, 0.205790, -0.618581, -0.546530, -0.090609, 0.108647, 0.099562, 0.190863, 0.396830, 0.183155, -0.347171, -0.331807, -0.034849, 0.103769, 0.115158, 0.200526, 0.337435, 0.142355, -0.267599, -0.253986, -0.017599, 0.088344, 0.110878, 0.190802, 0.297931, 0.063765, -0.214669, -0.214639, -0.045529, 0.054745, 0.074363, 0.151043, 0.225477, -0.019735, -0.126519, -0.162555, -0.071667, 0.005162, 0.039533, 0.094780, 0.079670, 0.000000, 0.000000, 0.000000, 0.000000, 1.893836, 1.428475, 0.570946, 0.410750, 0.369341, 0.525449, -0.284402, -0.233000, 0.496256, 0.592513, 0.202011, 0.013880, -0.073682, -0.078557, -0.284131, -0.230884, 0.203392, 0.306295, 0.103281, -0.040850, -0.123458, -0.153109, -0.262347, -0.204966, 0.110464, 0.215695, 0.082772, -0.053227, -0.117544, -0.158612, -0.190361, -0.127528, 0.073824, 0.155219, 0.090465, -0.005964, -0.068120, -0.126083, -0.086857, -0.049278, 0.061125, 0.100761, 0.070666, 0.029845, -0.035797, -0.067691, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.865611, 1.997974, 0.870843, 0.128795, -0.107574, -0.263906, -0.203624, -0.202013, 0.529007, 0.760240, 0.090655, -0.265120, -0.343814, -0.305258, -0.256093, -0.188724, 0.316650, 0.495317, 0.008675, -0.284664, -0.359775, -0.280069, -0.249462, -0.163427, 0.246532, 0.380266, -0.016963, -0.260922, -0.338458, -0.216046, -0.171319, -0.076259, 0.227977, 0.353473, 0.053123, -0.173559, -0.250736, -0.122735, -0.106619, -0.026963, 0.154701, 0.211565, 0.081487, -0.085071, -0.127318, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.715262, 1.549037, 0.343349, 0.043923, -0.149270, -0.204230, -0.212060, -0.197709, 0.570547, 0.555728, 0.057532, -0.071173, -0.186749, -0.221644, -0.254535, -0.157599, 0.366903, 0.341167, -0.026281, -0.135056, -0.186505, -0.213061, -0.238287, -0.137372, 0.277806, 0.270712, -0.029784, -0.138647, -0.156131, -0.164412, -0.151628, -0.030013, 0.244774, 0.238397, -0.002237, -0.107992, -0.104918, -0.102642, -0.069707, 0.014794, 0.152913, 0.158229, 0.016707, -0.072131, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.712003, 1.759193, 0.478120, -0.310684, -0.339116, -0.331502, -0.216527, 0.045770, 0.749851, 0.529590, -0.059038, -0.278863, -0.305701, -0.279929, -0.212912, 0.011643, 0.481453, 0.334622, -0.084652, -0.240806, -0.266820, -0.248911, -0.193983, 0.011483, 0.392028, 0.265620, -0.079699, -0.197737, -0.223764, -0.182795, -0.125677, 0.020794, 0.275163, 0.186854, -0.050717, -0.105861, -0.123729, -0.108405, -0.063769, 0.057698, 0.169513, 0.113902, -0.029172, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 2.021426, 1.780307, -0.069124, -0.121218, -0.112855, -0.124373, -0.185885, 0.003594, 0.746667, 0.514855, -0.074974, -0.134492, -0.128360, -0.114138, -0.169626, -0.036863, 0.434529, 0.308846, -0.069781, -0.119934, -0.122280, -0.103445, -0.127746, -0.035492, 0.314755, 0.235352, 0.002762, -0.072695, -0.077763, -0.066231, -0.093772, -0.034935, 0.206473, 0.200546, 0.067243, -0.003949, -0.056265, -0.048997, -0.046196, 0.028152, 0.139351, 0.128562, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.727495, -0.030880, -0.179780, -0.179999, -0.173777, -0.102076, -0.139960, 0.008262, 0.502247, -0.011085, -0.146245, -0.135515, -0.141409, -0.091326, -0.078860, 0.069528, 0.327436, 0.034885, -0.097475, -0.104211, -0.115915, -0.078854, -0.045027, 0.085866, 0.269978, 0.055105, -0.050770, -0.071618, -0.082548, -0.054862, -0.004524, 0.092552, 0.183200, 0.046563, -0.012511, -0.059421, -0.055743, -0.026982, 0.019595, 0.070822, 0.087983, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.534060, -0.785495, -0.195635, 0.048602, 0.142654, 0.050455, -0.179295, -0.812129, -1.153868, -0.676663, -0.154677, 0.118103, 0.210561, 0.126350, -0.142962, -0.694818, -0.669820, -0.451756, -0.121192, 0.123927, 0.200976, 0.144969, -0.080921, -0.448491, -0.404761, -0.224002, -0.037179, 0.147194, 0.259493, 0.210800, -0.036890, -0.335619, -0.167529, -0.128471, -0.029296, 0.169403, 0.221202, 0.149749, -0.004878, -0.155212, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.207001, -0.675023, -0.101513, 0.071805, 0.047497, 0.011168, 0.194415, -0.036614, -0.797351, -0.549624, -0.107695, 0.063393, 0.075601, 0.068420, 0.180494, -0.046538, -0.409790, -0.319412, -0.088324, 0.054839, 0.077721, 0.075060, 0.112307, -0.011967, -0.188726, -0.171370, -0.029413, 0.094148, 0.117341, 0.079735, 0.093447, 0.003297, -0.081064, -0.105140, 0.007308, 0.076126, 0.099647, 0.080158, 0.051206, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.167258, 0.667706, 0.099161, -0.029816, -0.005524, 0.089652, -0.025251, 0.018515, 0.707918, 0.506316, 0.078559, -0.069221, -0.027998, 0.037852, -0.030988, 0.038712, 0.326231, 0.286966, 0.042777, -0.086744, -0.047630, -0.011740, -0.011793, 0.027001, 0.112217, 0.105540, -0.014652, -0.103068, -0.079179, -0.021986, -0.020405, -0.006103, 0.037147, 0.030382, -0.013224, -0.055269, -0.048383, -0.030908, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.229750, 0.813474, 0.091878, -0.054360, -0.075657, -0.041689, -0.037730, 0.029680, 0.746141, 0.618680, 0.060465, -0.100775, -0.116291, -0.070220, -0.054038, 0.054252, 0.396550, 0.370870, 0.026337, -0.107714, -0.118689, -0.084929, -0.068379, 0.005625, 0.216693, 0.226052, 0.012092, -0.071286, -0.087949, -0.067795, -0.067798, 0.006964, 0.116779, 0.122719, 0.026868, -0.039468, -0.062593, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.314858, 0.763292, 0.084118, -0.008010, -0.059897, -0.056827, -0.037169, 0.103548, 0.873038, 0.576265, 0.053391, -0.049747, -0.095407, -0.094125, -0.058240, 0.133707, 0.521114, 0.385288, 0.040020, -0.085352, -0.116205, -0.103279, -0.067258, 0.105473, 0.346594, 0.205381, -0.015985, -0.097027, -0.111509, -0.094548, -0.052584, 0.085624, 0.188775, 0.122259, -0.012451, -0.109744, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.229535, 0.711611, 0.125793, -0.017388, -0.041576, -0.042918, -0.066324, 0.084141, 0.822735, 0.487817, 0.086859, -0.046031, -0.075700, -0.086679, -0.093507, 0.071015, 0.462878, 0.293282, 0.036410, -0.072834, -0.086965, -0.084406, -0.102309, -0.013954, 0.210842, 0.149494, -0.009569, -0.063833, -0.070043, -0.056510, -0.065190, 0.029282, 0.124402, 0.072679, -0.026765, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.193122, -0.647007, -0.019351, 0.042672, 0.034868, 0.023843, 0.041052, -0.129209, -0.808274, -0.451366, -0.033830, 0.029315, 0.031357, 0.041128, 0.050909, -0.091232, -0.400245, -0.279219, -0.045075, 0.003757, -0.001387, 0.029261, 0.073966, 0.019218, -0.165225, -0.164737, -0.036447, -0.019581, 0.010580, 0.037779, 0.045981, -0.003693, -0.080015, -0.069239, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.035733, -0.058702, 0.027562, -0.000758, 0.038588, 0.037169, 0.054664, -0.110247, -0.685935, -0.095789, 0.007666, -0.007834, 0.032124, 0.036652, 0.024280, -0.120481, -0.335565, -0.073072, 0.003276, 0.006340, 0.044968, 0.071258, 0.034977, -0.102793, -0.194301, -0.042033, 0.007900, 0.047617, 0.070179, 0.046446, 0.008808, -0.038240, -0.097784, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.087033, -0.491030, -0.092519, -0.009039, 0.031692, 0.012130, -0.082150, -0.510763, -0.968740, -0.491698, -0.133201, -0.009776, 0.036695, 0.020137, -0.096819, -0.536069, -0.339090, -0.208721, -0.055634, 0.036651, 0.088739, 0.074591, -0.025316, -0.240991, -0.118801, -0.077144, -0.024975, 0.040074, 0.062269, 0.040516, -0.047581, -0.124188, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.958125, -0.536910, -0.095829, -0.005364, 0.010211, 0.009851, 0.150439, -0.085391, -0.786417, -0.509221, -0.107511, 0.009859, 0.010641, -0.001818, 0.106277, -0.075885, -0.254149, -0.185155, -0.041763, 0.035105, 0.059729, 0.027987, 0.029304, -0.061162, -0.113244, -0.108957, -0.037816, 0.005552, 0.048640, 0.047977, 0.002759, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.997227, 0.562900, 0.132771, 0.045858, 0.034213, 0.065138, 0.017496, 0.106420, 0.822329, 0.558757, 0.148488, 0.053094, 0.050127, 0.057743, 0.026131, 0.154106, 0.271184, 0.206246, 0.076080, 0.006093, 0.002887, 0.011359, 0.009082, 0.061904, 0.119990, 0.093774, 0.037806, 0.008387, -0.000504, -0.005060, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.085364, -0.700616, -0.153291, -0.007812, 0.039924, 0.020183, 0.007969, -0.106222, -0.861579, -0.670631, -0.164035, 0.006308, 0.050191, 0.051347, 0.019000, -0.074363, -0.298381, -0.307733, -0.064941, 0.031762, 0.068301, 0.058214, 0.053433, -0.018947, -0.156873, -0.170036, -0.067355, 0.006759, 0.032620, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.122871, 0.661593, 0.067769, 0.007451, -0.014542, -0.008313, -0.004374, 0.123571, 0.895610, 0.624699, 0.093536, 0.000707, -0.056682, -0.054517, -0.025490, 0.175753, 0.463760, 0.331170, 0.097242, -0.024014, -0.129022, -0.142941, -0.112148, 0.075089, 0.229106, 0.178855, 0.036015, -0.082424, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.068881, 0.553680, 0.059709, -0.008994, -0.014384, 0.007586, 0.015200, 0.145612, 0.890003, 0.519487, 0.068116, -0.009633, -0.022707, -0.023148, -0.037072, 0.079243, 0.350109, 0.270406, 0.074385, -0.052104, -0.068214, -0.059765, -0.034513, 0.064001, 0.165758, 0.131136, 0.009241, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.024907, 0.487588, 0.048158, 0.008422, 0.018830, 0.007004, -0.019167, 0.130457, 0.830368, 0.486366, 0.084531, -0.001625, 0.009721, 0.020666, 0.020981, 0.063063, 0.247517, 0.248672, 0.049659, 0.015599, -0.021070, 0.004096, 0.010791, 0.052122, 0.104986, 0.077323, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.841741, 0.101074, -0.005838, -0.003577, -0.027022, 0.028015, -0.013801, 0.117194, 0.697208, 0.150588, 0.018839, 0.015484, 0.013286, 0.015579, 0.026344, 0.151099, 0.282441, 0.065225, 0.014475, -0.026727, -0.043020, -0.016673, 0.012511, 0.059143, 0.110228, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.013911, -0.474955, -0.119206, -0.048587, -0.005093, 0.004944, -0.088413, -0.480608, -0.677682, -0.427321, -0.121567, 0.014459, 0.086348, 0.013804, -0.156421, -0.503123, -0.287136, -0.222859, -0.062480, 0.012030, 0.048304, 0.011325, -0.116512, -0.260852, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.871871, -0.471921, -0.073538, -0.006530, -0.025673, 0.002981, 0.143776, -0.166168, -0.454861, -0.350928, -0.113324, -0.014987, 0.021772, 0.048993, 0.072901, -0.112301, -0.216385, -0.204651, -0.095182, 0.000481, 0.028901, 0.050842, 0.015483, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.895415, 0.469747, 0.061605, 0.047864, 0.038617, 0.050622, 0.025033, 0.158522, 0.418337, 0.298618, 0.085496, 0.028654, 0.043140, 0.025720, 0.010220, 0.103091, 0.198259, 0.166252, 0.049710, -0.022876, -0.059428, -0.037327, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.956604, -0.590895, -0.147439, -0.033291, 0.008462, 0.054906, 0.027420, -0.096950, -0.440628, -0.462170, -0.135691, 0.004183, 0.062224, 0.096048, 0.075690, -0.041681, -0.219660, -0.245371, -0.104449, 0.033919, 0.089737, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.990970, -0.626707, -0.099406, -0.029999, 0.021516, -0.001841, -0.021835, -0.167863, -0.568888, -0.461499, -0.178661, -0.046871, 0.067535, 0.078787, 0.060402, -0.098973, -0.295058, -0.253400, -0.069554, 0.017995, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.941055, -0.484654, -0.049657, -0.019673, 0.001199, 0.016332, 0.011010, -0.182010, -0.506364, -0.402679, -0.146582, -0.018686, 0.014188, 0.027191, -0.021323, -0.140722, -0.242740, -0.177738, -0.070251, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.903796, -0.448782, -0.130933, -0.010974, -0.015476, -0.025531, -0.019290, -0.089579, -0.436551, -0.403256, -0.094952, -0.018897, 0.023119, 0.013399, 0.020611, -0.071058, -0.189870, -0.167389, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.787272, -0.182135, -0.040920, 0.008057, 0.019180, 0.032885, 0.028163, -0.152745, -0.401118, -0.116563, -0.034240, 0.015351, 0.039267, 0.054482, -0.024592, -0.113204, -0.179208, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.523361, 0.850975, 0.223036, -0.062035, -0.143237, -0.072875, 0.220055, 0.944140, 0.729833, 0.575536, 0.204096, -0.008621, -0.123914, -0.007422, 0.257743, 0.599143, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.145418, 0.827462, 0.217999, 0.054334, -0.036640, -0.077005, -0.319434, 0.203227, 0.444090, 0.442017, 0.193625, 0.018593, -0.009905, -0.082831, -0.025493, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.082948, 0.707948, 0.175890, -0.009149, 0.010285, 0.103359, 0.078351, 0.142814, 0.308065, 0.292507, 0.088243, -0.023544, -0.049290, 0.040633, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.159295, -1.124483, -0.267649, 0.038125, 0.087826, 0.097969, 0.035776, -0.104745, -0.510023, -0.542664, -0.207596, 0.061063, 0.134342, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.240260, 0.936864, 0.175470, 0.044345, -0.167150, -0.171595, -0.134632, 0.160720, 0.491755, 0.387173, 0.026882, -0.107274, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.163272, -0.777745, -0.131811, 0.003892, 0.014994, 0.027179, 0.060063, -0.158193, -0.459859, -0.367049, -0.107570, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.154222, -0.690639, -0.206207, -0.048078, 0.053842, 0.038417, 0.024997, -0.095754, -0.435078, -0.439077, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.886746, -0.078642, 0.009322, -0.011791, 0.012919, -0.006622, -0.049828, -0.102945, -0.249901, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.220703, -0.947819, -0.365103, -0.152076, -0.005016, -0.069747, -0.278884, -0.792069, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.865066, -0.761221, -0.185410, 0.004248, 0.013823, 0.135947, 0.349382, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.938425, -0.615745, -0.094865, -0.007197, -0.124714, -0.140317, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.905758, 0.617248, 0.189716, -0.052760, -0.064273, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.838319, -0.728063, -0.091074, -0.058055, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.872991, -0.801078, -0.175314, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.895108, -0.475955, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.626200;
   gmeansl << 0.114832, 0.094554, 0.110079, 0.107600, 0.082117, 0.072799, 0.075908, 0.070672, 0.067235, 0.085492, 0.096833, 0.089794, 0.090223, 0.102777, 0.104021, 0.088298, 0.075538, 0.080190, 0.098492, 0.104377, 0.105746, 0.114144, 0.111863, 0.099518, 0.088171, 0.087729, 0.104472, 0.120152, 0.114447, 0.116455, 0.105879, 0.092785, 0.089487, 0.093043, 0.099275, 0.097575, 0.088788, 0.078419, 0.102819, 0.076610, 0.059722, 0.077735, 0.069094, 0.071039, 0.043221, 0.034445, 0.051672, 0.031643, 0.027865, 0.050874, -0.893237, -0.715003, -0.674218, -0.679307, -0.583466, -0.601813, -0.654802, -0.564247, -0.471949, -0.518844, -0.654541, -0.688891, -0.686494, -0.756022, -0.787184, -0.669907, -0.554776, -0.534366, -0.715933, -0.781469, -0.795022, -0.858307, -0.899796, -0.765891, -0.634829, -0.624617, -0.756847, -0.846206, -0.799159, -0.865180, -0.883565, -0.757627, -0.664105, -0.679768, -0.718055, -0.695348, -0.640293, -0.634254, -0.841834, -0.596989, -0.424023, -0.561509, -0.551131, -0.572207, -0.344909, -0.290437, -0.443497, -0.263889, -0.194235, -0.400376;
   THIS->m_LDAclassifier.SetTrainingParams(probl, logdetSigmal, Rl, gmeansl);
   

   //TODO: AA Hard Coded - to be removed
 /*  
   EigenVectorTypeD priorQ;       MatrixUtils::ReadMatrixFromFile("Z:/COPY/Copy/Temp/Alpha3T Visit/Settings/prior30.txt", priorQ);
   EigenVectorTypeD logDetSigmaQ; MatrixUtils::ReadMatrixFromFile("Z:/COPY/Copy/Temp/Alpha3T Visit/Settings/logDetSigma30.txt", logDetSigmaQ);
   EigenMatrixTypeD RQ;           MatrixUtils::ReadMatrixFromFile("Z:/COPY/Copy/Temp/Alpha3T Visit/Settings/R30.txt", RQ);
   EigenMatrixTypeD gmeansQ;      MatrixUtils::ReadMatrixFromFile("Z:/COPY/Copy/Temp/Alpha3T Visit/Settings/gmeans30.txt", gmeansQ);
*/
   EigenVectorTypeD priorQ;       MatrixUtils::ReadMatrixFromFile("Z:/COPY/Copy/Temp/prior50.txt"      , priorQ      );
   EigenVectorTypeD logDetSigmaQ; MatrixUtils::ReadMatrixFromFile("Z:/COPY/Copy/Temp/logDetSigma50.txt", logDetSigmaQ);
   EigenMatrixTypeD RQ;           MatrixUtils::ReadMatrixFromFile("Z:/COPY/Copy/Temp/R50.txt"          , RQ          );
   EigenMatrixTypeD gmeansQ;      MatrixUtils::ReadMatrixFromFile("Z:/COPY/Copy/Temp/gmeans50.txt"     , gmeansQ     );

   THIS->m_QDAClassifier.SetTrainingParams(priorQ, logDetSigmaQ, RQ, gmeansQ);

   //MatrixUtils::WriteMatrixToFile(priorQ, "J:/Matlab/PCAD/priorQ.txt");
   //MatrixUtils::WriteMatrixToFile(logDetSigmaQ, "J:/Matlab/PCAD/logdetSigmaQ.txt");
   //MatrixUtils::WriteMatrixToFile(RQ, "J:/Matlab/PCAD/RQ.txt");
   //MatrixUtils::WriteMatrixToFile(gmeansQ, "J:/Matlab/PCAD/gmeansQ.txt");
} // constructor
//////////////////////////////////////////////////////////////////////////////////////////
void ProstaCADMainWindow::on_pushButton_LoadFeatures_clicked()
{
  unsigned int MeanWindowSize[2] = {3, 5};
  for(unsigned int i = 0; i < 2; i++)
  {
    ccipd::TextureFeatureFirstOrderParameters::Pointer pFeatureMeanParameters = ccipd::TextureFeatureFirstOrderParameters::New(MeanWindowSize[i]);
    FeatureDescriptionType FeatureDescription = "Mean";
    ccipd::FeatureIDPointer pMeanFeatureID(ccipd::FeatureID::New(ccipd::TextureFeatureMean , FeatureDescription, pFeatureMeanParameters));   
    THIS->m_FeatureIDs.push_back(pMeanFeatureID);
  }

  	// Add the feature to the feature list
	//VolRadiusType radius = {{1, 1, 1}};
 //   VolOffsetType offset = {{0, 0, 0}}; // offset zero means setting al lthe possible values of the offset vector 
	//unsigned int  histogramBins = 64;
 //   ccipd::TextureFeatureHaralickParameters::Pointer FeatureParameters = ccipd::TextureFeatureHaralickParameters::New(radius, offset, histogramBins);
 //   FeatureDescriptionType FeatureDescription = "HaralickEnergy";
 //   ccipd::FeatureIDPointer pHaralickEnergyFeatureID( ccipd::FeatureID::New(ccipd::TextureFeatureHaralickEnergy, FeatureDescription, FeatureParameters));
 //   THIS->m_FeatureIDs.push_back(pHaralickEnergyFeatureID);

  float Orient[48] = 
  {
    0.0000, 0.3927, 0.7854, 1.1781, 1.5708, 1.9635, 2.3562, 2.7489, 
    0.0000, 0.3927, 0.7854, 1.1781, 1.5708, 1.9635, 2.3562, 2.7489, 
    0.0000, 0.3927, 0.7854, 1.1781, 1.5708, 1.9635, 2.3562, 2.7489, 
    0.0000, 0.3927, 0.7854, 1.1781, 1.5708, 1.9635, 2.3562, 2.7489, 
    0.0000, 0.3927, 0.7854, 1.1781, 1.5708, 1.9635, 2.3562, 2.7489, 
    0.0000, 0.3927, 0.7854, 1.1781, 1.5708, 1.9635, 2.3562, 2.7489
  };

  float Wavelength[48] = 
  {
    2.8284, 2.8284, 2.8284, 2.8284, 2.8284, 2.8284,
    2.8284, 2.8284, 5.6569, 5.6569, 5.6569, 5.6569,
    5.6569, 5.6569, 5.6569, 5.6569, 8.2   , 8.2   ,
    8.2    , 8.2    , 8.2    , 8.2    , 8.2, 8.2,
    11.3137, 11.3137, 11.3137, 11.3137, 11.3137, 11.3137,
    11.3137, 11.3137, 22.6274, 22.6274, 22.6274, 22.6274,
    22.6274, 22.6274, 22.6274, 22.6274, 45.2548, 45.2548,
    45.2548, 45.2548, 45.2548, 45.2548, 45.2548, 45.2548
  };

  for(unsigned int i = 0; i < 48; i++)
  {
    ccipd::TextureFeatureGaborParameters::Pointer myParameters = ccipd::TextureFeatureGaborParameters::New((float)(1.0f/Wavelength[i]), Orient[i]);
    FeatureDescriptionType FeatureDescription = "Gabor";
    ccipd::FeatureIDPointer pGaborFeatureID( ccipd::FeatureID::New(ccipd::TextureFeatureGabor, FeatureDescription, myParameters));
    THIS->m_FeatureIDs.push_back(pGaborFeatureID); 
  }

}

void ProstaCADMainWindow::on_pushButton_FastProcess_clicked()
{
	   //QString studyFolderPath;// = GUI;
	
     // 1. Get the INI file path
     string iniFilePath = QFileDialog::getOpenFileName(this, tr("Please, select the INI file to load from ...."), "", tr("INI Files (*.ini)")).toStdString()  ;
     //string iniFilePath = "G:/Copy/Temp/Alpha3T.ini";
	    
	   // 2. Load File names from the ini file
     TrainingSetFileNames files = LoadTrainingDataFileNames(iniFilePath);
 

	// 3. Load All Volumes Available ()
	// Function: LoadTrainingSet(TrainingSetFileNames files)
	VolumeImagesContainer      vecVolumeImagesT2, vecVolumeImagesADC;
	VolumeMaskImagesContainer  vecMaskImages, vecLabelImages;
	for (unsigned int i = 0; i < files.size(); i++)
	{
		vecVolumeImagesT2 .push_back(FlipImage<VolumeImageType    >(LoadITKImage<VolumeImageType    >(files.at(i).at(1)), 1));
		vecVolumeImagesADC.push_back(FlipImage<VolumeImageType    >(LoadITKImage<VolumeImageType    >(files.at(i).at(2)), 1));
		vecMaskImages     .push_back(FlipImage<VolumeMaskImageType>(LoadITKImage<VolumeMaskImageType>(files.at(i).at(3)), 1));
		if(files.at(i).size() == 5)
			vecLabelImages  .push_back(FlipImage<VolumeMaskImageType>(LoadITKImage<VolumeMaskImageType>(files.at(i).at(4)), 1)); // This file is optional
  }

  
    // 4. Force Masks to be binary
    //for (unsigned int i = 0; i < files.size(); i++)
    //{
    //    vecMaskImages.at(i) = MaskPixelValue<MaskPixelType, VolumeDimension>(vecMaskImages.at(i), 0, 0, 1);
	   // if(files.at(i).size() == 5)
		  //  vecLabelImages.at(i) =  MaskPixelValue<MaskPixelType, VolumeDimension>(vecLabelImages.at(i), 1, 1, 0); // optional
    //}

	// Load T2 Preprocessing (Should be a function
	// 4. Load the Standardization Reference Image/Histogram  (Optional Step, if it is only a set or if all sets are coming from the same institution)
	CSimpleIniA ini;
	ini.LoadFile(iniFilePath.data());
	
	std::string refVolumeImageFilePath(ini.GetValue("Preprocessing_T2", "StandardRefVolumeImage", ""));
	VolumeImagePointer refVolumeImage = NULL;
	bool bStandardize = !refVolumeImageFilePath.empty();
	if(bStandardize) 
		VolumeImagePointer refVolumeImage = LoadITKImage<VolumeImageType>(refVolumeImageFilePath);

	std::string biasFieldCorrectionSigma(ini.GetValue("Preprocessing_T2", "BiasFieldCorrectionSigma", ""));
	float bfcSigma = 0.0f;
	bool bCorrectBF = !biasFieldCorrectionSigma.empty();
	if(bCorrectBF)
		bfcSigma = (float)std::atof(biasFieldCorrectionSigma.c_str());

	std::string maskCroppingPadding(ini.GetValue("Preprocessing_T2", "CropPaddingInMM", ""));
	float bCropPadding = 0.0f;
	bool bCrop = !maskCroppingPadding.empty();
	if(bCrop)
		bCropPadding = (float)std::atof(maskCroppingPadding.c_str());

	std::string normalizationString(ini.GetValue("Preprocessing_T2", "Normalize", ""));
	bool bNormalize = !normalizationString.empty();


	// 5. Preprocess All loaded volumes  a. Bias Field, b. Crop, c. Standardize
	VolumeRegionsContainer vecBoundingBoxes_beforeCropping, vecBoundingBoxes_afterCropping;

  //itk::Image< TPixel, VImageDimension >::PointType
   typedef VolumeImageType::PointType VolumePointType;
   typedef std::vector<VolumePointType> VolumePointsContainer;

   VolumePointsContainer vecOriginPoints_beforeCropping;

	for (unsigned int i = 0; i < files.size(); i++)
	{
		// Resize All to the mask, we dont need to apply this to the T2 as it is done inside the preprocessT2 function
		vecVolumeImagesADC.at(i) = ResizeImage(vecVolumeImagesADC.at(i), vecMaskImages.at(i));
		if(files.at(i).size() == 5)
			vecLabelImages.at(i) = ResizeMask(vecLabelImages.at(i), vecMaskImages.at(i));

	// Options for this function should be included in the ini file

		vecBoundingBoxes_beforeCropping.push_back(vecVolumeImagesT2.at(i)->GetLargestPossibleRegion());
    vecOriginPoints_beforeCropping.push_back(vecVolumeImagesT2.at(i)->GetOrigin());
    

		vecBoundingBoxes_afterCropping.push_back(
			PreprocessT2<VolumeImageType, VolumeMaskImageType>(vecVolumeImagesT2.at(i), vecVolumeImagesT2.at(i), 
														   refVolumeImage, vecMaskImages.at(i), bStandardize, 100, 25, 
														   bCrop, bCropPadding, bNormalize, bCorrectBF, bfcSigma));
		// No preprocessing for ADC
		// Input T2 image and mask were cropped, so we need to crop the remaining inputs
		if(bCrop)
		{
			vecVolumeImagesADC.at(i) = CropVolume(vecVolumeImagesADC.at(i), vecBoundingBoxes_afterCropping.back());
			if(files.at(i).size() == 5)
				vecLabelImages.at(i) = CropMask(vecLabelImages.at(i), vecBoundingBoxes_afterCropping.back());
		}
  } // for

  // Testing ONLY
  //WriteITKImage<VolumeImageType>(vecVolumeImagesT2.at(0), "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/preprocessed_6_3fast.mha");
	

  // 5. Load the optimal set of features
  FeatureIDCollection T2_FeatureIDs  = LoadFeaturesFromFile(iniFilePath, "Features_T2" );
  FeatureIDCollection ADC_FeatureIDs = LoadFeaturesFromFile(iniFilePath, "Features_ADC");

 
  // 6. Extract Features
  VolumeFeaturesConstImagesContainer vecVolumeFeaturesT2, vecVolumeFeaturesADC;
  FeatureCollectionPointer pFeatureCollection_T2  = ccipd::FeatureCollection::New();
  FeatureCollectionPointer pFeatureCollection_ADC = ccipd::FeatureCollection::New();
  for (unsigned int i = 0; i < files.size(); i++)
	{
		cout << "\n" << T2_FeatureIDs.size() + ADC_FeatureIDs.size() << " Features Extraction for Study: " << files.at(i).at(0) << " started ...\n" ;

    if(T2_FeatureIDs.size() > 0)
    {
      pFeatureCollection_T2->SetVolume(vecVolumeImagesT2.at(i));
      VolumeFeaturesConstPointer pFeatureVectorImage_T2 = VolumeFeaturesConstPointer(pFeatureCollection_T2->GetFeatures(T2_FeatureIDs));
      vecVolumeFeaturesT2.push_back(pFeatureVectorImage_T2);
    }

    if(ADC_FeatureIDs.size() > 0)
    {
      pFeatureCollection_ADC->SetVolume(vecVolumeImagesADC.at(i));
      VolumeFeaturesConstPointer pFeatureVectorImage_ADC = VolumeFeaturesConstPointer(pFeatureCollection_ADC->GetFeatures(ADC_FeatureIDs));
      vecVolumeFeaturesADC.push_back(pFeatureVectorImage_ADC);
    }
  }
  
  cout << "\n----- Done Ectracting Features ... " << "\n";

  // Testing ONLY
  //WriteITKImage<VolumeImageType>(  GetChannelByIndex<VolumeFeaturesType, VolumeImageType>(const_cast<VolumeFeaturesType*>(vecVolumeFeaturesT2.at(0).GetPointer()), 48)
  //                               , "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/Feature48_fast.mha");
  //WriteITKImage<VolumeImageType>(  GetChannelByIndex<VolumeFeaturesType, VolumeImageType>(const_cast<VolumeFeaturesType*>(vecVolumeFeaturesT2.at(0).GetPointer()), 49)
  //                               , "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/Feature49_fast.mha");
  //
  //WriteITKImage<VolumeMaskImageType>(  vecMaskImages.at(0)
  //                                   , "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/mask_fast.mha");
    
  // 7. Prepare for Classification  a. segment (load prostate masks), b. reshape to matrix, c.whiten data
  EigenMatrixTypeD featuresMatrixT2(0, 0), featuresMatrixADC(0, 0), labelsMatrix(0, 0);
  for (unsigned int i = 0; i < files.size(); i++)
	{
    if(vecVolumeFeaturesT2.size() > 0)
    {
		  EigenMatrixTypeD tempfeaturesMatrixT2 = 
			  PrepareForClassification<VolumeVectorType, VolumeMaskImageType, double, -1, -1, 1>(
		    const_cast<VolumeVectorType*>(vecVolumeFeaturesT2.at(i).GetPointer()), vecMaskImages.at(i));
		  featuresMatrixT2.resize(featuresMatrixT2.rows() + tempfeaturesMatrixT2.rows(), tempfeaturesMatrixT2.cols());
		  featuresMatrixT2.bottomRows(tempfeaturesMatrixT2.rows()) = tempfeaturesMatrixT2;
    }

    if(vecVolumeFeaturesADC.size() > 0)
    {
		  EigenMatrixTypeD tempfeaturesMatrixADC = 
		  PrepareForClassification<VolumeVectorType, VolumeMaskImageType, double, -1, -1, 1>(
		    const_cast<VolumeVectorType*>(vecVolumeFeaturesADC.at(i).GetPointer()), vecMaskImages.at(i));
		  featuresMatrixADC.resize(featuresMatrixADC.rows() + tempfeaturesMatrixADC.rows(), tempfeaturesMatrixADC.cols());
		  featuresMatrixADC.bottomRows(tempfeaturesMatrixADC.rows()) = tempfeaturesMatrixADC;
    }

		// Convert the label image to a vector image // TODO: Should be moved to some separate function
		if(files.at(i).size() == 5) // Do we have label images
		{
			typedef itk::ComposeImageFilter<VolumeMaskImageType>   ScalarImageToVectorImageFilterType;
			ScalarImageToVectorImageFilterType::Pointer imageToVectorImageFilter = ScalarImageToVectorImageFilterType::New();
			imageToVectorImageFilter->SetInput(0, vecLabelImages.at(i));
			imageToVectorImageFilter->Update();
    
			EigenMatrixTypeD templabelsMatrix = 
				ReshapeImage<MaskVectorType, VolumeMaskImageType, double, -1, -1, 1>(
			  const_cast<MaskVectorType*>(/*vecLabelImages.at(i)*/imageToVectorImageFilter->GetOutput()), vecMaskImages.at(i));
			labelsMatrix.resize(labelsMatrix.rows() + templabelsMatrix.rows(), templabelsMatrix.cols());
			labelsMatrix.bottomRows(templabelsMatrix.rows()) = templabelsMatrix;
		}
	}

    cout << "\n 7. Done Reforming Matrices ...\n" ;

	// 8. Concatenate the Features Matrices of T2 and ADC
	// featuresMatrixT2 & featuresMatrixADC have the same number of rows (voxels) and columns C1 and C2 respectively
	// The resultant matrix will have the same original numbe rof rows and (C1+C2) colums
	EigenMatrixTypeD featuresMatrix(featuresMatrixT2.rows(), featuresMatrixT2.cols() + featuresMatrixADC.cols());
	
	if(featuresMatrixT2.cols() > 0) 
		featuresMatrix.leftCols(featuresMatrixT2.cols()) = featuresMatrixT2;
	if(featuresMatrixADC.cols() > 0)
		featuresMatrix.rightCols(featuresMatrixADC.cols()) = featuresMatrixADC;
	 
	//// 8. Save reshaped matrices for matlab
 // MatrixUtils::WriteMatrixToFile(featuresMatrixT2 , outputFolder + "/featuresMatrixT2.txt" );
 // MatrixUtils::WriteMatrixToFile(featuresMatrixADC, outputFolder + "/featuresMatrixADC.txt");
 // MatrixUtils::WriteMatrixToFile(labelsMatrix     , outputFolder + "/labelsMatrix.txt"     );
 // cout << "\n 8. Done Saving Started ...\n" ;

	// 9. Load the Trained ClassifierTrain decision boundaries
  EigenVectorTypeD priorQ;       MatrixUtils::ReadMatrixFromFile(ini.GetValue("Classifier_QDA", "prior"      , ""), priorQ      );
  EigenVectorTypeD logDetSigmaQ; MatrixUtils::ReadMatrixFromFile(ini.GetValue("Classifier_QDA", "logDetSigma", ""), logDetSigmaQ);
  EigenMatrixTypeD RQ;           MatrixUtils::ReadMatrixFromFile(ini.GetValue("Classifier_QDA", "R"          , ""), RQ          );
  EigenMatrixTypeD gmeansQ;      MatrixUtils::ReadMatrixFromFile(ini.GetValue("Classifier_QDA", "gmeans"     , ""), gmeansQ     );
    
	// 10. Classify
	ccipdQDAClassifier      qdaClassifier;
	qdaClassifier.SetTrainingParams(priorQ, logDetSigmaQ, RQ, gmeansQ);
	EigenVectorTypeD classificationResult = qdaClassifier.Classify(featuresMatrix, 1/*1 = Cancer*/, true);

	// 11. Reshape the resultant matrix
	// Starting from this step: ONLY one Volume set is supported because this is not training any more
	VolumeImagePointer pProbabilitiesImage = DuplicateImage<VolumeImageType>(vecVolumeImagesT2[0]);
  pProbabilitiesImage->FillBuffer(-1.0f); // These values will be changed only in the prostate volume, otherwise it will not be touched
  itk::Size<3> imSize = vecVolumeImagesT2[0]->GetBufferedRegion().GetSize() ;

   for (unsigned int  slice = 0, n = 0; slice < imSize[2]; slice++)
   {
     for (unsigned int x = 0; x < imSize[0]; x++)
     {
       for (unsigned int y = 0; y < imSize[1]; y++)
       {
         VolumeFeaturesType::IndexType pixelIndex = {{x, y, slice}};
         // Check if this pixel is above zero in the mask
         if(vecMaskImages[0]->GetPixel(pixelIndex) > 0)
         {
            pProbabilitiesImage->SetPixel(pixelIndex, (InternalPixelType)classificationResult[n]);
            n++;
         }
       }
     }
   }


   // 12. Now, enlarge the probabilities image to match the original size of the T2 image
   	VolumeImagePointer tempImage = DuplicateImage<VolumeImageType>(vecVolumeImagesT2[0]);
	  tempImage->SetRegions(vecBoundingBoxes_beforeCropping[0]); 
	  tempImage->SetOrigin(vecOriginPoints_beforeCropping[0]);
    tempImage->Allocate();
	  tempImage->FillBuffer(-1.0f); 
    pProbabilitiesImage = InsertImage<VolumeImageType, VolumeImageType>(pProbabilitiesImage, tempImage, vecBoundingBoxes_afterCropping[0].GetIndex());

	 // 13. Save the probabilities image - flipped so that it coincides with the original
	 WriteITKImage<VolumeImageType>(  FlipImage<VolumeImageType>(pProbabilitiesImage, 1)
                                  , ini.GetValue("Output", "probabilities", "")
                                 );
	
	 cout << "\nSuccess ....\nProbabilities image was saved to " << ini.GetValue("Output", "probabilities", "");
	

}

//////////////////////////////////////////////////////////////////////////////////////////
ProstaCADMainWindow::~ProstaCADMainWindow()
{
  SaveSettings();
}
//////////////////////////////////////////////////////////////////////////////////////////

bool ProstaCADMainWindow::RetrieveSettings()
{
  // last used paths
  THIS->m_lastVolumePath_DCE = THIS->m_settings.value("VolumePaths/DCE", "").toString();

  THIS->m_lastOriginalVolumePath = THIS->m_settings.value("OriginalVolume/path", "").toString();
  //THIS->m_lastVolumePath = THIS->m_settings.value("Volume/path", "").toString();
  THIS->m_lastProstateMaskPath = THIS->m_settings.value("PMask/path", "").toString();
  THIS->m_lastHeatmapPath = THIS->m_settings.value("Heatmap/path", "").toString();
  THIS->m_lastprobabilitiesImagePath = THIS->m_settings.value("ProbImage/path", "").toString();
  THIS->m_lastImagePath = THIS->m_settings.value("SnapshotImage/path", "").toString();
  THIS->m_lastAppSnapshotPath = THIS->m_settings.value("AppSnapshotImage/path", "").toString();

	// Application Settings
	THIS->m_bFirstTimeOperation         = THIS->m_settings.value("App/FirstTimeOperation"                             , true ).toBool(  );

	
	
	
	// Preprocessing settings
	// Bias Field Correction BFC
	THIS->m_bCorrectForBiasField        = THIS->m_settings.value("Preprocessing/ApplyBiasFieldCorrection"              , true ).toBool(  );
	THIS->m_bUseCohenBFC                = THIS->m_settings.value("Preprocessing/UseCohen"                              , true ).toBool(  );
	THIS->m_sigmaBFC                    = THIS->m_settings.value("Preprocessing/BFC/Cohen/Sigma"                       , 6.00 ).toDouble();

	// Standardization
	THIS->m_bStandardize                = THIS->m_settings.value("Preprocessing/ApplyStandardization"                  , false).toBool(  );
	THIS->m_RefHistogramBinsNum         = THIS->m_settings.value("Preprocessing/Standardization/NumberOfHistogramBins" , 100  ).toUInt(  );
	THIS->m_RefHistogramMatchingPtsNum  = THIS->m_settings.value("Preprocessing/Standardization/NumberOfMatchingPoints", 25   ).toUInt(  );
	THIS->m_bUseRefHistogram            = THIS->m_settings.value("Preprocessing/UseRefHistogram"                       , true ).toBool(  );
	THIS->m_RefHistogramFilePath        = THIS->m_settings.value("Preprocessing/Standardization/RefHistogramFilePath"  , ""   ).toString();
	THIS->m_RefVolumeImageFilePath      = THIS->m_settings.value("Preprocessing/Standardization/RefVolumeFilePath"     , ""   ).toString();	
	
	// Cropping
	THIS->m_bCropOriginalVolume         = THIS->m_settings.value("Preprocessing/ApplyCropping"                         , true ).toBool(  );
	THIS->m_bCropAutomatically          = THIS->m_settings.value("Preprocessing/CropAutomatically"                     , false).toBool(  );
	THIS->m_CroppingPadding             = THIS->m_settings.value("Preprocessing/Cropping/padding"                      , 5.0  ).toDouble();

	// Normalization
	THIS->m_bNormalizeOriginalVolume    = THIS->m_settings.value("Preprocessing/ApplyNormalization"                    , false).toBool(  );

	return true;
}
//////////////////////////////////////////////////////////////////////////////////////////
bool ProstaCADMainWindow::SaveSettings()
{
  // Last used Paths
  THIS->m_settings.setValue("VolumePaths/DCE", THIS->m_lastVolumePath_DCE);
  THIS->m_settings.setValue("OriginalVolume/path", THIS->m_lastOriginalVolumePath);
  //THIS->m_settings.setValue("Volume/path", THIS->m_lastVolumePath);
  THIS->m_settings.setValue("PMask/path", THIS->m_lastProstateMaskPath);
  THIS->m_settings.setValue("Heatmap/path", THIS->m_lastHeatmapPath);
  THIS->m_settings.setValue("ProbImage/path", THIS->m_lastprobabilitiesImagePath);
  THIS->m_settings.setValue("SnapshotImage/path", THIS->m_lastImagePath);
  THIS->m_settings.setValue("AppSnapshotImage/path", THIS->m_lastAppSnapshotPath);


  // Application Settings
  THIS->m_settings.setValue("App/FirstTimeOperation", THIS->m_bFirstTimeOperation);

	
	
	// Preprocessing
	// Bias Field Correction BFC
	THIS->m_settings.setValue("Preprocessing/ApplyBiasFieldCorrection", THIS->m_bCorrectForBiasField);
	THIS->m_settings.setValue("Preprocessing/UseCohen"                , THIS->m_bUseCohenBFC        );
	cout << THIS->m_bUseCohenBFC;
	THIS->m_settings.setValue("Preprocessing/BFC/Cohen/Sigma"         , THIS->m_sigmaBFC            );

	// Standardization
	THIS->m_settings.setValue("Preprocessing/ApplyStandardization"                  , THIS->m_bStandardize              );
	THIS->m_settings.setValue("Preprocessing/Standardization/NumberOfHistogramBins" , THIS->m_RefHistogramBinsNum       );
	THIS->m_settings.setValue("Preprocessing/Standardization/NumberOfMatchingPoints", THIS->m_RefHistogramMatchingPtsNum);
	THIS->m_settings.setValue("Preprocessing/UseRefHistogram"                       , THIS->m_bUseRefHistogram          );
	THIS->m_settings.setValue("Preprocessing/Standardization/RefHistogramFilePath"  , THIS->m_RefHistogramFilePath      );
	THIS->m_settings.setValue("Preprocessing/Standardization/RefVolumeFilePath"     , THIS->m_RefVolumeImageFilePath    );	

	// Cropping
	THIS->m_settings.setValue("Preprocessing/ApplyCropping"     , THIS->m_bCropOriginalVolume);
	THIS->m_settings.setValue("Preprocessing/CropAutomatically" , THIS->m_bCropAutomatically );
	THIS->m_settings.setValue("Preprocessing/Cropping/padding"  , THIS->m_CroppingPadding    );

	// Normalization
	THIS->m_settings.setValue("Preprocessing/ApplyNormalization"  , THIS->m_bNormalizeOriginalVolume);



	return true;
}


//////////////////////////////////////////////////////////////////////////////////////////
void ProstaCADMainWindow::SlotExit() 
{
  this->hide();
  qApp->exit();
} // SlotExit
/////////////////////////////////////////////////////////////////////////////////////////


 /*void ProstaCADMainWindow::on_horizontalSlider_LevelSetValue_sliderMoved(int levelset)
 {
   THIS->m_LevelSetValue = levelset;

 }*/

// AA TODO
 void ProstaCADMainWindow::on_horizontalSlider_LevelSetValue_valueChanged(int levelset)
 {
   int x = levelset; x++;
 }
/////////////////////////////////////////////////////////////////////////////////////////

 void ProstaCADMainWindow::on_horizontalSlider_SliceNum_DCE_Features_valueChanged(int sliceNum)
  {
	  THIS->m_currentSliceNum_DCE_Features = sliceNum - 1;
    UpdateVTKImageSlice(THIS->m_ImageProp_DCE_Features, sliceNum - 1, THIS->m_bVerbose );
    ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
  }

 void ProstaCADMainWindow::on_horizontalSlider_SliceNum_DCE_valueChanged(int sliceNum)
  {
    THIS->m_currentSliceNum_DCE = sliceNum - 1;
    UpdateVTKImageSlice(THIS->m_ImageProp_DCE, sliceNum - 1, THIS->m_bVerbose );
    ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_currentSlice_valueChanged(int sliceNum)
  {
    THIS->m_currentSlice = sliceNum - 1;
    UpdateVTKImageSlice(THIS->m_ImageProp_T2, sliceNum - 1, THIS->m_bVerbose );
    //UpdateVTKImageSlice(THIS->m_MaskedVolumeImageProp, sliceNum - 1, THIS->m_bVerbose );
    //UpdateVTKImageSlice(THIS->m_HeatmapProp, sliceNum - 1, THIS->m_bVerbose );
    ui->qVTKWidget_Volume->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_currentSlicePreprocessed_valueChanged(int sliceNum)
  {
	  THIS->m_currentSlicePreprocessed = sliceNum - 1;
	  UpdateVTKImageSlice(THIS->m_PreprocessedImageProp, sliceNum - 1, THIS->m_bVerbose );
	  ui->qVTKWidget_Volume->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_currentSliceCurrentFeature_valueChanged(int sliceNum)
  {
	  THIS->m_currentSliceCurrentFeature = sliceNum - 1;
	  UpdateVTKImageSlice(THIS->m_CurrentFeatureImageProp, sliceNum - 1, THIS->m_bVerbose );
	  ui->qVTKWidget_Features->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_Window_valueChanged(int window)
  {
    UpdateVTKImageWindow(THIS->m_ImageProp_T2, window);
    ui->qVTKWidget_Volume->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_WindowPreprocessed_valueChanged(int window)
  {
	  UpdateVTKImageWindow(THIS->m_PreprocessedImageProp, window);
	  ui->qVTKWidget_Volume->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_Level_valueChanged(int level)
  {
    UpdateVTKImageLevel(THIS->m_ImageProp_T2, level);
    ui->qVTKWidget_Volume->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_LevelPreprocessed_valueChanged(int level)
  {
	  UpdateVTKImageLevel(THIS->m_PreprocessedImageProp, level);
	  ui->qVTKWidget_Volume->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_InputVolumeImageOpacity_valueChanged(int Opacity)
  {
    UpdateVTKPropTransparency(THIS->m_ImageProp_T2, (unsigned int)Opacity);
    ui->qVTKWidget_Volume->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_OpacityPreprocessed_valueChanged(int Opacity)
  {
	  UpdateVTKPropTransparency(THIS->m_PreprocessedImageProp, (unsigned int)Opacity);
	  ui->qVTKWidget_Volume->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_Opacity_DCE_valueChanged(int Opacity)
  {
	  UpdateVTKPropTransparency(THIS->m_ImageProp_DCE, (unsigned int)Opacity);
	  ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_Opacity_DCE_Features_valueChanged(int Opacity)
  {
	  UpdateVTKPropTransparency(THIS->m_ImageProp_DCE_Features, (unsigned int)Opacity);
	  ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
  }

  void ProstaCADMainWindow::on_horizontalSlider_OpacityCurrentFeature_valueChanged(int Opacity)
  {
	  UpdateVTKPropTransparency(THIS->m_CurrentFeatureImageProp, (unsigned int)Opacity);
	  ui->qVTKWidget_Features->GetRenderWindow()->Render();
  }

  //void ProstaCADMainWindow::on_horizontalSlider_MaskedVolumeImageOpacity_valueChanged(int Opacity)
  //{
  //  UpdateVTKPropTransparency(THIS->m_MaskedVolumeImageProp, (unsigned int)Opacity);
  //  ui->qVTKWidget_Volume->GetRenderWindow()->Render();
  //}
  
  void ProstaCADMainWindow::on_horizontalSlider_HeatMapVolumeImageOpacity_valueChanged(int Opacity)
  {
    UpdateVTKPropTransparency(THIS->m_HeatmapProp, (unsigned int)Opacity);
    ui->qVTKWidget_Volume->GetRenderWindow()->Render();
  }


  void ProstaCADMainWindow::on_action_Load_Mask_Prostate_triggered()
  {
  QString prostateMaskFileName = QFileDialog::getOpenFileName(this, tr( "Please, select a file to load the prostate mask from ...."), 
                                                      THIS->m_lastProstateMaskPath, tr("Files (*.mha *.mhd *.vtk)"));   
  
  if(prostateMaskFileName.isEmpty())
  {
    statusBar()->showMessage("Warning: Empty or invalid Prostate File path ...");
	  return;
  }
  
  THIS->m_lastProstateMaskPath = prostateMaskFileName;

  // If the user loaded a volume before, everything is reset
  if(THIS->m_pProstateMask && !THIS->m_pOriginalVolume && !THIS->m_pProbabilitiesImage)
  {
    ResetApp();
  }

	// Load Mask
  THIS->m_pProstateMask = ccipd::LoadITKImage<VolumeMaskImageType>(prostateMaskFileName.toStdString());

  if (!THIS->m_pProstateMask)
  {
    std::cerr << "Error(563-29): Unable to load Mask file ..." << std::endl;
    statusBar()->showMessage("Error(563-29): Unable to load Mask file ...");
    return;
  }

  this->setWindowTitle(QCoreApplication::applicationName() + "  -  " + prostateMaskFileName);

	this->setWindowTitle("ProstaCAD - " + prostateMaskFileName);


	if (THIS->m_pOriginalVolume && THIS->m_pProstateMask->GetBufferedRegion().GetSize() != THIS->m_pOriginalVolume->GetBufferedRegion().GetSize())
	{
	  std::cout << "Warning(846-29-33): Prostate Mask will be resized to match the size of the current volume ..." << std::endl;
	  statusBar()->showMessage("Warning(846-29-33): Prostate Mask will be resized to match the size of the current volume ...");

	  THIS->m_pProstateMask = ccipd::ResizeMask(THIS->m_pProstateMask, THIS->m_pOriginalVolume, true);
	}

  THIS->m_pProstateMask = FlipImage<VolumeMaskImageType>(THIS->m_pProstateMask, 1);
	statusBar()->showMessage("Mask file Loaded Successfully ....");
  
  }

  void ProstaCADMainWindow::on_actionFile_Load_StandardImage_triggered()
  {
	  // Let the user select a directory to load the volume from 
	  QString FilePath = QFileDialog::getOpenFileName(this,
		  tr("Please, select the reference volume image file for standardization ...."), "J:/Data", tr("Meta Image Files (*.mha *.mhd *.vtk)"));

	  // Check the returned directory path
	  if (FilePath.isEmpty())
	  {
		  // write a warning on the status bar
		  statusBar()->showMessage("Empty or invalid file path ....");
		  return;
	  }

	  // load the volume
	  try
	  {
		  THIS->m_pRefVolume = CohenCorrectBiasField(ccipd::LoadITKImage<VolumeImageType>(FilePath.toStdString()));
	  }
	  catch (std::exception)
	  {
		  statusBar()->showMessage("Exception ....");
		  return;
	  }

	  if (!THIS->m_pRefVolume)
	  {
		  // write a warning on the status bar
		  statusBar()->showMessage("Invalid Volume ....");
		  //return;
	  }
	  else
	  {
      THIS->m_pRefVolume = FlipImage<VolumeImageType>(THIS->m_pRefVolume, 1);
		  statusBar()->showMessage("Reference Volume Image for Standardization was loaded successfully ....");
	  }
  }

void ProstaCADMainWindow::on_action_LoadVolumeImage_triggered()
{
      // Let the user select a directory to load the volume from 
      QString FilePath = QFileDialog::getOpenFileName(this,
        tr("Please, select a file to load the volume from ...."), THIS->m_lastOriginalVolumePath, tr("Image Files (*.mha *.mhd *.vtk *.vtk)"));

      // Check the returned directory path
      if (FilePath.isEmpty())
      {
        // write a warning on the status bar
        statusBar()->showMessage("Warning(633-47): Empty or invalid directory ....");
        return;
      }
 
	  THIS->m_lastOriginalVolumePath = FilePath;

      // load the volume
      try
      {
          THIS->m_pOriginalVolume = ccipd::LoadITKImage<VolumeImageType>(FilePath.toStdString());
	  }
      catch (std::exception)
      {
    	statusBar()->showMessage("Error(): Exception ....");
        return;
      }

      if(!THIS->m_pOriginalVolume)
      {
        // write a warning on the status bar
        DisplayStatusMessage(statusBar(), "Error(655-48): Unable to load Volume Image ..."
                            , StatusMessageHandler/*::MessageType*/::ERR );
        return;
      }

      this->setWindowTitle(QCoreApplication::applicationName() + FilePath);

      // Flip
      THIS->m_pOriginalVolume = FlipImage<VolumeImageType>(THIS->m_pOriginalVolume, 1);

	  // Now Display the loaded mask
	  renderVolumeAsSlices<VolumeImageType>(THIS->m_pOriginalVolume, ui->qVTKWidget_Volume, THIS->m_ImageProp_T2, THIS->m_currentSlice);
      initControlsValues(/*LatestDisplayedVolumeImage::*/ORIGINAL);
}

void ProstaCADMainWindow::on_action_LoadVolume_DCE_triggered()
{
      // Let the user select a directory to load the volume from 
      QString dirPath = QFileDialog::getExistingDirectory(this, 
      tr( "Please, select a directory to load the DCE volume from ...."), 
      THIS->m_lastVolumePath_DCE/*, QFileDialog::ShowDirsOnly | QFileDialog::DontUseNativeDialog*/);

      // Check the returned directory path
      if (dirPath.isEmpty())
      {
        // write a warning on the status bar
        statusBar()->showMessage("Warning(826-407): Empty or invalid directory ....");
        return;
      }
 
	    THIS->m_lastVolumePath_DCE = dirPath;

      // load the volume
      try
      {
		    // try to load the image
		    THIS->m_pVolume_DCE = LoadTimeSeries(dirPath.toStdString(), true ) ;
      }
      catch (...)
      {
    	  statusBar()->showMessage("Exception ....");
        return;
      }

      if(!THIS->m_pVolume_DCE)
      {
        // write an error on the status bar
        DisplayStatusMessage(statusBar(), "Error(656-408): Unable to load Volume Image ...", StatusMessageHandler/*::MessageType*/::ERR);
        return;
      }

	  // Show the path on the title bar
      this->setWindowTitle(QCoreApplication::applicationName() + dirPath);

      // Flip over the y-axis
      THIS->m_pVolume_DCE = FlipImage<VolumeVectorType>(THIS->m_pVolume_DCE, 1);


      THIS->m_pPreprocessedVolume_DCE = THIS->m_pVolume_DCE;


	  //SaveImage(ExtractFeatureImage(THIS->m_pVolume_DCE, 0).GetPointer(), "G:/Im0.mha", true);
	  //SaveImage(ExtractFeatureImage(THIS->m_pVolume_DCE, 1).GetPointer(), "G:/Im1.mha", true);

	  // Now Display a slice of the loaded volume 
	  THIS->m_pCurrentDCEVolume = ExtractFeatureImage(THIS->m_pVolume_DCE, 0/*THIS->m_currentTimePointIndex_DCE*/); 
	  renderVolumeAsSlices<VolumeImageType>(THIS->m_pCurrentDCEVolume, ui->qVTKWidget_Viewer_DCE, THIS->m_ImageProp_DCE, THIS->m_currentSliceNum_DCE);
      UpdateSliceTimePointSlider(THIS->m_pVolume_DCE, ui->horizontalSlider_TimePoint_DCE, ui->doubleSpinBox_TimePoint_DCE);
	  initControlsValues(/*LatestDisplayedVolumeImage::*/DCE);
}

void ProstaCADMainWindow::on_pushButton_Preprocess_clicked()
{
	if (!THIS->m_pOriginalVolume)  // No Original volume loaded yet
	{
		on_action_LoadVolumeImage_triggered();

		if (!THIS->m_pOriginalVolume)  // double-check
		{
			statusBar()->showMessage("Warning(751-41): No Volume Image was loaded ...");
		}
	}

	// Additional Checks
	on_checkBox_BiasFieldCorrection_toggled(THIS->m_bCorrectForBiasField);
	on_checkBox_CropAutomatically_toggled(THIS->m_bCropAutomatically);
	on_checkBox_ApplyStandardization_toggled(THIS->m_bStandardize);
	on_checkBox_CropManually_toggled(!THIS->m_bCropAutomatically);
	on_checkBox_Normalize_toggled(THIS->m_bNormalizeOriginalVolume);

	THIS->croppingBoundingBox = 
	PreprocessT2<VolumeImageType, VolumeMaskImageType>(THIS->m_pOriginalVolume, THIS->m_pPreprocessedVolume, THIS->m_pRefVolume, THIS->m_pProstateMask,
		                                                    THIS->m_bStandardize, THIS->m_RefHistogramBinsNum, THIS->m_RefHistogramMatchingPtsNum,
														                            THIS->m_bCropAutomatically, (float)THIS->m_CroppingPadding,
														                            THIS->m_bNormalizeOriginalVolume,
														                            THIS->m_bCorrectForBiasField, (float)THIS->m_sigmaBFC);
	
		// Now Display the loaded mask
		renderVolumeAsSlices<VolumeImageType>(THIS->m_pPreprocessedVolume, ui->qVTKWidget_Volume, THIS->m_PreprocessedImageProp, THIS->m_currentSlice);
		initControlsValues(/*LatestDisplayedVolumeImage::*/PREPROCESSED);
}

void ProstaCADMainWindow::on_groupBox_OriginalVolumeControls_toggled(bool showOriginalVolume)
{
	if (!THIS->m_pOriginalVolume)
	{
		on_action_LoadVolumeImage_triggered();

		if (!THIS->m_pOriginalVolume)
		{
			ui->groupBox_OriginalVolumeControls->setChecked(false);
			statusBar()->showMessage("Warning(672-41): No Volume Image Loaded ...");
			return;
		}
	}

	THIS->m_ImageProp_T2->SetVisibility(showOriginalVolume);
	ui->qVTKWidget_Volume->GetRenderWindow()->Render();
}

void ProstaCADMainWindow::on_groupBox_DCEVolumeControls_toggled(bool showDCE)
{
	if (!THIS->m_pVolume_DCE)
	{
		on_action_LoadVolume_DCE_triggered();

		if (!THIS->m_pVolume_DCE)
		{
			ui->groupBox_DCEVolumeControls->setChecked(false);
			statusBar()->showMessage("Warning(916-491): No DCE Volume Image Loaded ...");
			return;
		}
	}

	THIS->m_ImageProp_DCE->SetVisibility(showDCE);
	ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
}

void ProstaCADMainWindow::on_groupBox_PreprocessedVolumeControls_toggled(bool showPreprocessedVolume)
{
	if (!THIS->m_pPreprocessedVolume)
	{
		ui->groupBox_PreprocessedVolumeControls->setChecked(false);
		statusBar()->showMessage("Warning(760-41): No Preprocessed Volume Image to display, press \"Preprocess\" first ...");
		return;
	}

	THIS->m_PreprocessedImageProp->SetVisibility(showPreprocessedVolume);
	ui->qVTKWidget_Volume->GetRenderWindow()->Render();
}

//void ProstaCADMainWindow::DisplayErrorMessage(QMainWindow *pWindow, QString message, unsigned int /*blinkingTime*/)
//{
//	//m_pErrorMessageLabel = new QLabel();
//	THIS->m_pErrorMessageLabel->setText(message);
//	THIS->m_pErrorMessageLabel->setStyleSheet("QLabel { background-color: red; color: white}");
//	pWindow->statusBar()->addPermanentWidget(THIS->m_pErrorMessageLabel, 1);
//
//	//THIS->m_pErrorMEssageTimer = new QTimer();
//	//connect(THIS->m_pErrorMessageTimer, SIGNAL(timeout()), this, SLOT(blinkErrorMessage()));
//	//THIS->m_pErrorMessageTimer->start(blinkingTime/8);
//}

void ProstaCADMainWindow::on_action_File_Load_Histogram_triggered()
{
    //// Let the user select a directory to load the volume from 
    //  QString FilePath = QFileDialog::getOpenFileName(this,
    //    tr("Please, select a file to load the Reference Histogram from ..."), "J:/Data", tr("Histogram Files (*.csv)"));

    //  // Check the returned file path
    //  if (FilePath.isEmpty())
    //  {
    //    // write a warning on the status bar
    //    statusBar()->showMessage("Empty/Invalid file path or User canceled operation ....");
    //    return;
    //  }

    //  try
    //  {
    //    // load the histogram
    //    THIS->m_pReferenceHistogram = LoadHistogram<HistogramTypeD>(FilePath.toStdString());
    //    
    //    // Apply it to the current volume if already loaded
    //    if(THIS->m_pOriginalVolume)
    //    {
    //      THIS->m_pOriginalVolume =  StandardizeImage(THIS->m_pOriginalVolume);
    // 
    //    }
    //  }
    //  catch (QException)
    //  {
    //	  statusBar()->showMessage("Exception ....");
    //    return;
    //  }

    //  if(!THIS->m_pOriginalVolume)
    //  {
    //    // write a warning on the status bar
    //    statusBar()->showMessage("Invalid Volume ....");
    //    return;
    //  }

}

  void ProstaCADMainWindow::on_action_LoadVolume_triggered()
  {
      // Let the user select a directory to load the volume from 
      QString volumeDirectory = QFileDialog::getExistingDirectory(this, tr( "Please, select a directory to load the volume from ...."));

      // Check the returned directory path
      if (volumeDirectory.isEmpty())
      {
        // write a warning on the status bar
        statusBar()->showMessage("Empty or invalid directory ....");
        return;
      }
 
      // load the volume
      try
      {
        THIS->m_pOriginalVolume = CohenCorrectBiasField(LoadVolume(volumeDirectory.toStdString(), true));
        //THIS->m_pOriginalVolume = NormalizeMRI(THIS->m_pOriginalVolume);
      }
      catch (std::exception)
      {
    	statusBar()->showMessage("Exception ....");
        return;
      }

      if(!THIS->m_pOriginalVolume)
      {
        // write a warning on the status bar
        statusBar()->showMessage("Invalid Volume ....");
        return;
      }

      renderVolume(ui->qVTKWidget_Volume, (VolumeImageConstPointer)THIS->m_pOriginalVolume, true);
      initControlsValues(/*LatestDisplayedVolumeImage::*/ORIGINAL);
  }

  //void ProstaCADMainWindow::on_pushButton_resetCamera_clicked()
  //{
  //  THIS->m_pViewer->GetRenderer()->ResetCamera();
  //  THIS->m_pViewer->Render();
  //}

  void ProstaCADMainWindow::on_qxtCheckComboBox_Features_DCE_checkedItemsChanged(const QStringList & items)
  {
	  THIS->requested_DCE_Features = items;
	  
	  //int listSize = items.count();
	  //for(int i = 0; i < listSize; i++)
	  //{

	  //}

  }

void ProstaCADMainWindow::on_pushButton_ExractKineticFeatures_DCE_clicked()
{
	// TODO: to be moved to outer function to keep level separation and abstraction
	  typedef itk::DCEFeaturesFilter< VolumeVectorType, VolumeImageType > DCEFilter;
	  DCEFilter::Pointer pDCEFilter = DCEFilter::New();
    pDCEFilter->SetInput(THIS->m_pPreprocessedVolume_DCE);
	  //pDCEFilter->SetDeltaT(0.5);
	  pDCEFilter->Update();

	  THIS->m_pVectorImage_DCE_Features = VolumeVectorType::New();
    THIS->m_pVectorImage_DCE_Features->SetVectorLength((unsigned int)pDCEFilter->GetNumberOfOutputs());
    THIS->m_pVectorImage_DCE_Features->SetRegions(THIS->m_pVolume_DCE->GetBufferedRegion());
    THIS->m_pVectorImage_DCE_Features->Allocate();
	  
	  for(unsigned int i = 0; i < pDCEFilter->GetNumberOfOutputs(); i++)
	  {
//	     SetChannelByIndex<VolumeVectorType, VolumeImageType>(THIS->m_pVectorImage_DCE_Features, (VolumeImagePointer)pDCEFilter->GetOutput(i), i);
	  }

	  statusBar()->showMessage("Feature Extraction Done ...");


    	 // Let the user select a directory to load the volume from 
	 QString dirPath = QFileDialog::getExistingDirectory(this, 
		tr( "Please, select a directory to save the DCE kinetic features to ...."), 
		THIS->m_lastVolumePath_DCE);

      // Check the returned directory path
      if (dirPath.isEmpty())
      {
        // write a warning on the status bar
        statusBar()->showMessage("Warning(826-407): Empty or invalid directory ....");
        return;
      }
 
      //THIS->m_lastVolumePath_DCE = dirPath.toStdString() +  ;


  	WriteITKImage<VolumeImageType>(pDCEFilter->GetMaximumUptake()   , dirPath.toStdString() + "/DCE_MaxUptake.mha"       );
	  WriteITKImage<VolumeImageType>(pDCEFilter->GetTimeToPeak()      , dirPath.toStdString() + "/DCE_TimeToPeak.mha"      );
	  WriteITKImage<VolumeImageType>(pDCEFilter->GetRateOfUptake()    , dirPath.toStdString() + "/DCE_RateOfUptake.mha"    );
	  WriteITKImage<VolumeImageType>(pDCEFilter->GetRateOfWashout()   , dirPath.toStdString() + "/DCE_RateOfWashout.mha"   );
	  WriteITKImage<VolumeImageType>(pDCEFilter->GetEnhancement()     , dirPath.toStdString() + "/DCE_Enhancement.mha"     );
	  WriteITKImage<VolumeImageType>(pDCEFilter->GetEnhancementRatio(), dirPath.toStdString() + "/DCE_EnhancementRatio.mha");



}

void ProstaCADMainWindow::on_pushButton_SaveDCEKineticFeatures_clicked()
{
  //	 // Let the user select a directory to load the volume from 
	 //QString dirPath = QFileDialog::getExistingDirectory(this, 
		//tr( "Please, select a directory to save the DCE kinetic features to ...."), 
		//THIS->m_lastVolumePath_DCE);

  //    // Check the returned directory path
  //    if (dirPath.isEmpty())
  //    {
  //      // write a warning on the status bar
  //      statusBar()->showMessage("Warning(826-407): Empty or invalid directory ....");
  //      return;
  //    }
 
  //    //THIS->m_lastVolumePath_DCE = dirPath.toStdString() +  ;


  //	WriteITKImage<VolumeImageType>(pDCEFilter->GetMaximumUptake()   , dirPath.toStdString() + "/DCE_MaxUptake.mha"       );
	 // WriteITKImage<VolumeImageType>(pDCEFilter->GetTimeToPeak()      , dirPath.toStdString() + "/DCE_TimeToPeak.mha"      );
	 // WriteITKImage<VolumeImageType>(pDCEFilter->GetRateOfUptake()    , dirPath.toStdString() + "/DCE_RateOfUptake.mha"    );
	 // WriteITKImage<VolumeImageType>(pDCEFilter->GetRateOfWashout()   , dirPath.toStdString() + "/DCE_RateOfWashout.mha"   );
	 // WriteITKImage<VolumeImageType>(pDCEFilter->GetEnhancement()     , dirPath.toStdString() + "/DCE_Enhancement.mha"     );
	 // WriteITKImage<VolumeImageType>(pDCEFilter->GetEnhancementRatio(), dirPath.toStdString() + "/DCE_EnhancementRatio.mha");
}


void ProstaCADMainWindow::on_pushButton_ExractFeatures_DCE_clicked()
{
	// TODO: to be moved to outer function to keep level separation and abstraction

	  int listSize = THIS->requested_DCE_Features.count();

	  THIS->m_pVectorImage_DCE_Features = VolumeVectorType::New();
    THIS->m_pVectorImage_DCE_Features->SetVectorLength(listSize);
    THIS->m_pVectorImage_DCE_Features->SetRegions(THIS->m_pVolume_DCE->GetBufferedRegion());
    THIS->m_pVectorImage_DCE_Features->Allocate();


	  for(int i = 0; i < listSize; i++)
	  {
		  QString requestedFeatureName = THIS->requested_DCE_Features[i];
		  
		  typedef itk::BoxImageFilter< VolumeVectorType, VolumeImageType > DCEFilter;
		  DCEFilter::Pointer pDCEFilter = NULL;

		  if(requestedFeatureName == "Max") 
			   pDCEFilter = itk::DCEMaxFilter< VolumeVectorType, VolumeImageType >::New();
		  else if(requestedFeatureName == "Mean") 
			   pDCEFilter = itk::DCEMeanFilter< VolumeVectorType, VolumeImageType >::New();
		  else if(requestedFeatureName == "Median") 
			   pDCEFilter = itk::DCEMedianFilter< VolumeVectorType, VolumeImageType >::New();
		  else if(requestedFeatureName == "Min") 
			   pDCEFilter = itk::DCEMinFilter< VolumeVectorType, VolumeImageType >::New();
		  else if(requestedFeatureName == "StdDev") 
			   pDCEFilter = itk::DCEStdDevFilter< VolumeVectorType, VolumeImageType >::New();
		  else if(requestedFeatureName == "Sum") 
			   pDCEFilter = itk::DCESumFilter< VolumeVectorType, VolumeImageType >::New();
		  else if(requestedFeatureName == "Variance") 
			   pDCEFilter = itk::DCEVarianceFilter< VolumeVectorType, VolumeImageType >::New();
		
		//typedef itk::DCEVarianceFilter< VolumeVectorType, VolumeImageType > DCEFilter;
		//DCEFilter::Pointer pDCEFilter = DCEFilter::New();

			pDCEFilter->SetInput(THIS->m_pVolume_DCE);
			pDCEFilter->Update();
			
			
			THIS->m_pCurrentDCEFeature = pDCEFilter->GetOutput(); 
			SetChannelByIndex<VolumeVectorType, VolumeImageType>(THIS->m_pVectorImage_DCE_Features, THIS->m_pCurrentDCEFeature, i);


	  }
	
	        // Now Display the first requested feature
	  		renderVolumeAsSlices<VolumeImageType>(THIS->m_pCurrentDCEFeature, ui->qVTKWidget_Viewer_DCE, THIS->m_ImageProp_DCE_Features, THIS->m_currentSliceNum_DCE_Features);
			//UpdateSliceTimePointSlider(THIS->m_pVolume_DCE, ui->horizontalSlider_TimePoint_DCE, ui->doubleSpinBox_TimePoint_DCE);
			initControlsValues(/*LatestDisplayedVolumeImage::*/DCEFEATURE);
	  
	  
	

}

  void ProstaCADMainWindow::on_pushButton_ExtractFeatures_clicked()
  {
    if (0 == THIS->m_FeatureIDs.size())
    {
      DisplayStatusMessage(statusBar(), "Error(963-12): No Features were Selected ...."
                            , StatusMessageHandler/*::MessageType*/::ERR );
      return;
    }

    // Extract the Features - Calculate feature 3D Image (Volume)
    
    if (THIS->m_pPreprocessedVolume)
    {
    	THIS->m_pFeatureCollection->SetVolume(THIS->m_pPreprocessedVolume);
    }
    else if(THIS->m_pOriginalVolume)
    {
    	statusBar()->showMessage("Warning(981-86): Preprocessed Volume Image is not available, Original Volume will be used instead ...");
    	THIS->m_pFeatureCollection->SetVolume(THIS->m_pOriginalVolume);
    }
    else
    {
        DisplayStatusMessage(statusBar(), "Error(989-40): No Volume has been loaded, please load volume first ..."
            , StatusMessageHandler::/*MessageType::*/ERR );
    	return;
    }
	
    cout << "\nStarted Extracting " << THIS->m_FeatureIDs.size() << " Features ....\n";
    statusBar()->showMessage("Feature Extraction started ....");


    THIS->m_pFeatureVectorImage = ccipd::VolumeFeaturesConstPointer(THIS->m_pFeatureCollection->GetFeatures(THIS->m_FeatureIDs));
    
    cout << "\n"<<THIS->m_pFeatureVectorImage->GetNumberOfComponentsPerPixel()<< " Features were extracted \n";
    cout << "\nFeature Extraction done ....\n";
    statusBar()->showMessage("Feature Extraction done ....");

    // Render the first Calculated Feature
    on_listWidget_Features_currentRowChanged(0);
    ui->listWidget_Features->setCurrentRow(0);


    // Update Required control Tools
    //ui->groupBox_Segmentation->setEnabled(true);
    ui->groupBox_Classification->setEnabled(true);


// AA Testing ONLY
    //WriteITKImage<VolumeImageType>(  GetChannelByIndex<VolumeFeaturesType, VolumeImageType>(const_cast<VolumeFeaturesType*>(THIS->m_pFeatureVectorImage.GetPointer()), 48)
    //                               , "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/Feature48.mha");
    //WriteITKImage<VolumeImageType>(  GetChannelByIndex<VolumeFeaturesType, VolumeImageType>(const_cast<VolumeFeaturesType*>(THIS->m_pFeatureVectorImage.GetPointer()), 49)
    //                               , "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/Feature49.mha");
  
    //WriteITKImage<VolumeMaskImageType>(  THIS->m_pProstateMask
    //                                   , "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/mask.mha");

  }


  void ProstaCADMainWindow::on_listWidget_Features_currentRowChanged(int currentRow)
  {
	  if (THIS->m_pFeatureVectorImage)
	  {
		  THIS->m_pCurrentFeatureVolume = ExtractFeatureImage(THIS->m_pFeatureVectorImage, currentRow); 
		  renderVolumeAsSlices<VolumeImageType>(THIS->m_pCurrentFeatureVolume, ui->qVTKWidget_Features, THIS->m_CurrentFeatureImageProp, THIS->m_currentSliceCurrentFeature);
		  initControlsValues(/*LatestDisplayedVolumeImage::*/FEATURE);
	  }
  }

  //void ProstaCADMainWindow::on_comboBox_ExtractedFeatures_currentTextChanged(const QString & featureName)
  //{
  //  for (unsigned int i = 0; i < THIS->m_FeatureIDs.size(); i++)
  //  {
  //    if (THIS->m_FeatureIDs.at(i)->GetDescription() == featureName.toStdString())
  //    {
  //      const VolumeImageConstPointer pFeatureImage(THIS->m_pFeatureCollection->GetFeature(THIS->m_FeatureIDs.at(i)));
  //      // Render the First Feature
  //      renderVolume(ui->qVTKWidget_1, pFeatureImage); //TODO: pass imageprop so to keep the original volume
  //      return;
  //    }
  //  }
  //  statusBar()->showMessage("Error: No features found ...");
  //}

  void ProstaCADMainWindow::on_checkBox_Segment_toggled(bool bSegment)
  {
    // Check if the prostate mask was loaded before
    if(bSegment && !THIS->m_pProstateMask)
    {
        on_action_Load_Mask_Prostate_triggered();

        if (!THIS->m_pProstateMask)
        {
          ui->groupBox_OriginalVolumeControls->setChecked(false);
          statusBar()->showMessage("Warning(1065-49): No Prostate Mask Image Loaded ...");
          return;
        }
    }

    // Display the mask
    THIS->m_ImageProp_T2->SetVisibility(bSegment);
    ui->qVTKWidget_Volume->GetRenderWindow()->Render();

    THIS->m_ProstateMaskProp->SetVisibility(bSegment);
	  //THIS->m_pProstateLevelsetSurfaceActor->SetVisibility(showProstate);
	  ui->qVTKWidget_Classification->GetRenderWindow()->Render();
    //ui->action_SetProstateSurfaceColor->setEnabled(showProstate);

  }

  void ProstaCADMainWindow::on_pushButton_RemoveCurrentFeature_clicked()
  {
	  unsigned int currentRow = ui->listWidget_Features->currentRow();

	  //Remove from the list widget
	  ui->listWidget_Features->takeItem(currentRow);
	  ui->groupBox_Features->setTitle(tr("Features: %1").arg(ui->listWidget_Features->count()));

    // Remove from Feature Vector Image
    if(THIS->m_pFeatureVectorImage)
      THIS->m_pFeatureVectorImage = RemoveFeatureImage(THIS->m_pFeatureVectorImage.GetPointer(), currentRow);

    // display hierarchy of features before removal
    cout << "\nFeatures: before removing the selected one ...\n";
    DisplayFeaturesHierarchy();


    // Remove from the Feature List FeatureID
    for(unsigned int i = 0, n = 0; i < THIS->m_FeaturesHierarchy.size(); i++)
    {
      // Find the number of feature to be deleted
        for(unsigned int j = 0; j < THIS->m_FeaturesHierarchy.at(i).size(); j++)
        {
          if(n == currentRow)
          {
            THIS->m_FeaturesHierarchy.at(i).erase(THIS->m_FeaturesHierarchy.at(i).begin() + j);
            break;
          }
          n++;
        }

        if (THIS->m_FeaturesHierarchy.at(i).size() == 0)
        {
          THIS->m_FeaturesHierarchy.erase(THIS->m_FeaturesHierarchy.begin() + i);
          THIS->m_FeatureIDs.erase(THIS->m_FeatureIDs.begin() + i);
          break;
        }
    }
    
    // display hierarchy of features after removal
    cout << "\nFeatures: after removing the selected one ...\n";
    DisplayFeaturesHierarchy();


	  if ((unsigned int)ui->listWidget_Features->count() < THIS->m_FeatureIDs.size())
	  {
        DisplayStatusMessage(statusBar(), "Error(1024-43): Feature was not deleted .... Please, restart the program): "
                            , StatusMessageHandler::/*MessageType::*/ERR );
	  }
  }

void ProstaCADMainWindow::DisplayFeaturesHierarchy()
{
      // display hierarchy of features after removal
    for(unsigned int i = 0; i < THIS->m_FeaturesHierarchy.size(); i++)
    {
      cout << "\n";
      for(unsigned int j = 0; j < THIS->m_FeaturesHierarchy.at(i).size(); j++)
      {
         cout << THIS->m_FeaturesHierarchy.at(i).at(j) << "  ";
      }
    }
    cout << "\n";
}

  void ProstaCADMainWindow::on_pushButton_RemoveAllFeatures_clicked()
  {
	  //Remove All from the list widget
	  ui->listWidget_Features->clear();
	  ui->groupBox_Features->setTitle("Features: 0");

	  // Remove from the Feature List
	  THIS->m_FeatureIDs.clear();

	  if (THIS->m_FeatureIDs.size() != 0)
	  {
              DisplayStatusMessage(statusBar(), "Error(1024-43): Feature was not deleted .... Please, restart the program): "
                            , StatusMessageHandler::/*MessageType::*/ERR );

	  }
  }

  void ProstaCADMainWindow::on_pushButton_AddMeanFeature_clicked()
  {
     int windowSize = ui->spinBox_MeanFeature_WindowSize->value();
     ccipd::MapParametersType<ccipd::TextureFeatureMean>::AllParametersType::Pointer pFeatureMeanParameters =  ccipd::MapParametersType< ccipd::TextureFeatureMean >::AllParametersType::New(windowSize);
     FeatureDescriptionType FeatureDescription = "Mean";
     ccipd::FeatureIDPointer pMeanFeatureID(ccipd::FeatureID::New(ccipd::TextureFeatureMean , FeatureDescription, pFeatureMeanParameters));   
	 //THIS->m_FeatureIDs.push_back(pMeanFeatureID);
	 THIS->m_FeatureIDs.insert(THIS->m_FeatureIDs.begin(), pMeanFeatureID);

     statusBar()->showMessage(QString("Mean Feature added with Window size = %1 ...").arg(windowSize));

	 // Add the feature to the list widget
	 ui->listWidget_Features->insertItem(0, new QListWidgetItem(tr("Mean: Window Size(%1)").arg(windowSize)));
	 ui->groupBox_Features->setTitle(tr("Features: %1").arg(ui->listWidget_Features->count()));

   // Add the new feature to the hierarchy vector so that it could be deleted in future
   vector<unsigned int> newFeatureNode; newFeatureNode.push_back(ui->listWidget_Features->count()-1);
   THIS->m_FeaturesHierarchy.insert(THIS->m_FeaturesHierarchy.begin(), newFeatureNode); // equivalent to push_front
   DisplayFeaturesHierarchy();

  }

  void ProstaCADMainWindow::on_pushButton_AddMedianFeature_clicked()
  {
      int windowSize = ui->spinBox_MedianFeature_WindowSize->value();
      ccipd::MapParametersType<ccipd::TextureFeatureMedian>::AllParametersType::Pointer pFeatureMedianParameters =  ccipd::MapParametersType< ccipd::TextureFeatureMedian >::AllParametersType::New(windowSize);  //Window Size = 1
      FeatureDescriptionType FeatureDescription = "Median";
      ccipd::FeatureIDPointer pMedianFeatureID(ccipd::FeatureID::New(ccipd::TextureFeatureMedian , FeatureDescription, pFeatureMedianParameters));
      //THIS->m_FeatureIDs.push_back(pMedianFeatureID);
      THIS->m_FeatureIDs.insert(THIS->m_FeatureIDs.begin(), pMedianFeatureID);
	    statusBar()->showMessage(QString("Median Feature added with Window size = %1 ...").arg(windowSize));

	    // Add the feature to the list widget
	    ui->listWidget_Features->insertItem(0, new QListWidgetItem(tr("Median: Window Size(%1)").arg(windowSize)));
	    ui->groupBox_Features->setTitle(tr("Features: %1").arg(ui->listWidget_Features->count()));

   // Add the new feature to the hierarchy vector so that it could be deleted in future
   vector<unsigned int> newFeatureNode; newFeatureNode.push_back(ui->listWidget_Features->count()-1);
   THIS->m_FeaturesHierarchy.insert(THIS->m_FeaturesHierarchy.begin(), newFeatureNode); // equivalent to push_front
   DisplayFeaturesHierarchy();
  }

void ProstaCADMainWindow::on_pushButton_AddGaborFeature_clicked()
{
   float frequency = (float)(1.0f / ui->doubleSpinBox_GaborFeature_Wavelength->value());
   float angle     = (float)ui->doubleSpinBox_GaborFeature_Angle->value();
   ccipd::TextureFeatureGaborParameters::Pointer myParameters = ccipd::TextureFeatureGaborParameters::New(frequency, angle);
   FeatureDescriptionType FeatureDescription = "Gabor";
   ccipd::FeatureIDPointer pGaborFeatureID( ccipd::FeatureID::New( ccipd::TextureFeatureGabor, FeatureDescription, myParameters  ) );
   //THIS->m_FeatureIDs.push_back(pGaborFeatureID); 
   THIS->m_FeatureIDs.insert(THIS->m_FeatureIDs.begin(), pGaborFeatureID);
   statusBar()->showMessage(QString("Gabor Feature added with Frequency = %1 and Angle = %2 ...").arg(frequency).arg(angle));

   // Add the feature to the list widget
   ui->listWidget_Features->insertItem(0, new QListWidgetItem(tr("Gabor: F(%1) A(%2)").arg(frequency).arg(angle)));
   ui->groupBox_Features->setTitle(tr("Features: %1").arg(ui->listWidget_Features->count()));

   // Add the new feature to the hierarchy vector so that it could be deleted in future
   vector<unsigned int> newFeatureNode; newFeatureNode.push_back(ui->listWidget_Features->count()-1);
   THIS->m_FeaturesHierarchy.insert(THIS->m_FeaturesHierarchy.begin(), newFeatureNode); // equivalent to push_front
   DisplayFeaturesHierarchy();
}

void ProstaCADMainWindow::on_pushButton_AddHaralickFeature_clicked()
{
	// Add the feature to the feature list
	VolRadiusType radius = {{(unsigned long int)ui->spinBox_HaralickFeature_RadiusX->value(), (unsigned long int)ui->spinBox_HaralickFeature_RadiusY->value(), (unsigned long int)ui->spinBox_HaralickFeature_RadiusZ->value()}};
  VolOffsetType offset = {{ui->spinBox_HaralickFeature_OffsetX->value(), ui->spinBox_HaralickFeature_OffsetY->value(), ui->spinBox_HaralickFeature_OffsetZ->value()}}; 
	unsigned int  histogramBins = ui->spinBox_HaralickFeature_HistogramBins->value();
  ccipd::TextureFeatureHaralickParameters::Pointer FeatureParameters = ccipd::TextureFeatureHaralickParameters::New(radius, offset, histogramBins);
  FeatureDescriptionType FeatureDescription = "Haralick";
  ccipd::FeatureIDPointer pHaralickFeatureID( ccipd::FeatureID::New(ccipd::TextureFeatureHaralick, FeatureDescription, FeatureParameters));
  THIS->m_FeatureIDs.insert(THIS->m_FeatureIDs.begin(), pHaralickFeatureID);
	statusBar()->showMessage("New Haralick Feature was added successfully ...");

	// Add the feature to the list widget // Add the new feature to the hierarchy vector so that it could be deleted in future
	vector<unsigned int> newFeatureNode; 
  for(unsigned int i = 0; i < 17; i++)
  {
    newFeatureNode.push_back(ui->listWidget_Features->count());
    QString requiredFeatureName = ui->comboBox_requiredHaralickFeatures->itemText(i);
    ui->listWidget_Features->insertItem(i, new QListWidgetItem(tr("Haralick: %8 R(%1,%2,%3) O(%4,%5,%6) HB:(%7)").arg(radius[0]).arg(radius[1]).arg(radius[2]).arg(offset[0]).arg(offset[1]).arg(offset[2]).arg(histogramBins).arg(requiredFeatureName)));
  }
  
  ui->groupBox_Features->setTitle(tr("Features: %1").arg(ui->listWidget_Features->count()));
  THIS->m_FeaturesHierarchy.insert(THIS->m_FeaturesHierarchy.begin(), newFeatureNode); // equivalent to push_front
  DisplayFeaturesHierarchy();
}

void ProstaCADMainWindow::on_pushButton_AddIntensityFeature_clicked()
{
	// Add the feature to the feature list
	ccipd::TextureFeatureFirstOrderParameters::Pointer FeatureParameters = ccipd::TextureFeatureFirstOrderParameters::New();
	FeatureDescriptionType FeatureDescription = "Intensity";
	ccipd::FeatureIDPointer pIntensityFeatureID( ccipd::FeatureID::New(ccipd::TextureFeatureIntensity, FeatureDescription, FeatureParameters));
	THIS->m_FeatureIDs.insert(THIS->m_FeatureIDs.begin(), pIntensityFeatureID);
	statusBar()->showMessage("New Intensity Feature was added successfully ...");

	// Add the feature to the list widget
	ui->listWidget_Features->insertItem(0, new QListWidgetItem(tr("Intensity")));
	ui->groupBox_Features->setTitle(tr("Features: %1").arg(ui->listWidget_Features->count()));

   // Add the new feature to the hierarchy vector so that it could be deleted in future
   vector<unsigned int> newFeatureNode; newFeatureNode.push_back(ui->listWidget_Features->count()-1);
   THIS->m_FeaturesHierarchy.insert(THIS->m_FeaturesHierarchy.begin(), newFeatureNode); // equivalent to push_front
   DisplayFeaturesHierarchy();
}

void ProstaCADMainWindow::on_pushButton_Whiten_clicked()
{
  ////Testing
  ////SaveImage(THIS->m_pFeatureVectorImage.GetPointer(), "m_pFeatureVectorImage_before.mha", true);

  //statusBar()->showMessage("Feature Images whitening started ....");


  //// Whiten Mask Each Feature Image
  ////float NaN = std::numeric_limits<float>::quiet_NaN();
  //VolumeConstImagesContainer features; // This is a vectol of extracted features
  //for (unsigned int i = 0; i < THIS->m_FeatureIDs.size(); i++)
  //{
  //  const VolumeImageConstPointer featureImage = (VolumeImageConstPointer) ExtractFeatureImage(THIS->m_pFeatureVectorImage, i) ;
  //  // Normalizing Segmented Feature
  //  //features.push_back(NormalizeMRI(MaskImage(featureImage.GetPointer(), THIS->m_pProstateMask.GetPointer(), NaN)).GetPointer());

  //  // Normalizing Original Feature
  //   features.push_back(NormalizeVolume(featureImage).GetPointer());
  //}
  //THIS->m_pFeatureVectorImage = VolumeContainerToVolumeFeaturesConst( features );

  ////Testing
  ////SaveImage(THIS->m_pFeatureVectorImage.GetPointer(), "m_pFeatureVectorImage_after.mha", true);

  //statusBar()->showMessage("Feature Images were whitened successfully ....");
}

void ProstaCADMainWindow::on_pushButton_Classify_clicked()
{
  statusBar()->showMessage("Classification Started ....");
  // ReForms the features and prepares them for classification - Converts from VolumeImageType to EigenMatrixTypeF 
  // Prepare the data container (m x n matrix, m:the number of pixels in the whole 3D Image, n number of components of each pixel in the 3D Image)
  unsigned int featuresNumber = THIS->m_pFeatureVectorImage->GetNumberOfComponentsPerPixel();
  itk::Size<3> FeatureImagSize = THIS->m_pFeatureVectorImage->GetBufferedRegion().GetSize(); // Gets the dimensions of the Feature Image
  
  // Get Non-Zero Voxel Count
  // This is the number of non-zero valued voxels in the prostate mask, it will hold the whole number of voxels in the original image if no valid mask was loaded
  unsigned int prostateVoxelNum = 0;
  if(THIS->m_pProstateMask)
  {
	   itk::Size<3> ProstateMaskImageSize = THIS->m_pProstateMask->GetBufferedRegion().GetSize();
	  // Check Sizes
	  if(FeatureImagSize[0] != ProstateMaskImageSize[0] || FeatureImagSize[1] != ProstateMaskImageSize[1] || FeatureImagSize[2] != ProstateMaskImageSize[2])
	  {
		statusBar()->showMessage("Error: Feature Image Size is not equal to Mask Size ...");
		cout << "\nError: Feature Image Size is not equal to Mask Size ...";
		return;
	  }

	  prostateVoxelNum = GetPixelCount(THIS->m_pProstateMask.GetPointer());
  }
  else
  {
	  itk::Size<3> originalImageSize = THIS->m_pOriginalVolume->GetBufferedRegion().GetSize();
	  // Check Sizes
	  if(FeatureImagSize[0] != originalImageSize[0] || FeatureImagSize[1] != originalImageSize[1] || FeatureImagSize[2] != originalImageSize[2])
	  {
		  statusBar()->showMessage("Error: Feature Image Size is not equal to Mask Size ...");
		  cout << "\nError: Feature Image Size is not equal to Mask Size ...";
		  return;
	  }

	  prostateVoxelNum = (unsigned int) (originalImageSize[0] * originalImageSize[1] * originalImageSize[2]);
  }

  EigenMatrixTypeD dataToClassify(prostateVoxelNum, featuresNumber);

  float totalVoxelNum = 50.0f / (FeatureImagSize[0] * FeatureImagSize[1] * FeatureImagSize[2]);
  float progressBarValue = 0.0f;
  

    WriteITKImage<VolumeImageType>(  GetChannelByIndex<VolumeFeaturesType, VolumeImageType>(const_cast<VolumeFeaturesType*>(THIS->m_pFeatureVectorImage.GetPointer()), 48)
                                   , "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/Feature48.mha");
    WriteITKImage<VolumeImageType>(  GetChannelByIndex<VolumeFeaturesType, VolumeImageType>(const_cast<VolumeFeaturesType*>(THIS->m_pFeatureVectorImage.GetPointer()), 49)
                                   , "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/Feature49.mha");
    WriteITKImage<VolumeMaskImageType>(  THIS->m_pProstateMask
                                       , "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/mask.mha");






   //TODO: Change this to iterator with Index
   for (unsigned int slice = 0, n = 0; slice < FeatureImagSize[2]; slice++)
   {
     for (unsigned int x = 0; x < FeatureImagSize[0]; x++)
     {
       for (unsigned int y = 0; y < FeatureImagSize[1]; y++)
       {
         // Check if this is not zero in the 
         VolumeFeaturesType::IndexType pixelIndex = {{x, y, slice}};
         // Check if this pixel is above zero in the mask
         
         if(!THIS->m_pProstateMask || THIS->m_pProstateMask->GetPixel(pixelIndex) > 0)
         {
           VolumeFeaturesType::PixelType pixelValue = THIS->m_pFeatureVectorImage->GetPixel(pixelIndex);
           for (unsigned int f = 0; f < featuresNumber; f++)
           {
             dataToClassify(n, f) = pixelValue[f];
           } // for
           n++;
         } // if

         progressBarValue++;
//         ui->progressBar->setValue((int)(progressBarValue * totalVoxelNum));
       }
     }
   }

    // AA Testing ONLY
		//MatrixUtils::WriteMatrixToFile(dataToClassify, "Z:/COPY/Copy/Temp/Alpha3T Visit/fast/dataToClassifyQ.txt");

   // Apply Classification
   unsigned int classNum = 1; // 1 is the cancer
   EigenVectorTypeD classificationResult;
   if("LDA" == ui->comboBox_ClassifierType->currentText()) //LDA
   {
     statusBar()->showMessage("LDA Started ...");
     classificationResult = THIS->m_LDAclassifier.Classify(dataToClassify, classNum, THIS->m_bWhitenData);
   }
   else // QDA
   {
     statusBar()->showMessage("QDA Started ...");
     classificationResult = THIS->m_QDAClassifier.Classify(dataToClassify, classNum, THIS->m_bWhitenData);
   }
   
   //MatrixUtils::WriteMatrixToFile(classificationResult, "J:/Matlab/PCAD/classificationResultQ.txt");
   //MatrixUtils::ReadMatrixFromFile("J:/Matlab/PCAD/result_Satish.txt", classificationResult);


   //m_pProbabilitiesImage should be valid   
   // Post process results, prepare them for rendering - Converts from EigenLabelVector to VolumeImageType
   //THIS->m_pProbabilitiesImage->CopyInformation(THIS->m_pOriginalVolume);

   if(THIS->m_pPreprocessedVolume)
   {
		THIS->m_pProbabilitiesImage = DuplicateImage<VolumeImageType>(THIS->m_pPreprocessedVolume);
   }
   else
   {
	   THIS->m_pProbabilitiesImage = DuplicateImage<VolumeImageType>(THIS->m_pOriginalVolume);
   }
   THIS->m_pProbabilitiesImage->FillBuffer(-1.0f); // These values will be changed only in the prostate volume, otherwise it will not be touched


   progressBarValue = totalVoxelNum;
   totalVoxelNum = 100.0f / (FeatureImagSize[0] * FeatureImagSize[1] * FeatureImagSize[2]);

   for (unsigned int  slice = 0, n = 0; slice < FeatureImagSize[2]; slice++)
   {
     for (unsigned int x = 0; x < FeatureImagSize[0]; x++)
     {
       for (unsigned int y = 0; y < FeatureImagSize[1]; y++)
       {
         VolumeFeaturesType::IndexType pixelIndex = {{x, y, slice}};
         // Check if this pixel is above zero in the mask
         if(!THIS->m_pProstateMask || THIS->m_pProstateMask->GetPixel(pixelIndex) > 0)
         {
            THIS->m_pProbabilitiesImage->SetPixel(pixelIndex, (InternalPixelType)classificationResult[n]);
            n++;
         }

         progressBarValue++;
//       ui->progressBar->setValue((int)(progressBarValue * totalVoxelNum));
       }
     }
   }

   statusBar()->showMessage("Classification Done ..... ");
   
   // Here we need to resize (enlarge) the probabilities image to match the origina volume's size 
   VolumeImagePointer tempImage = DuplicateImage<VolumeImageType>(THIS->m_pOriginalVolume); 
   tempImage->FillBuffer(-1.0);
   THIS->m_pProbabilitiesImage = ccipd::InsertImage<VolumeImageType, VolumeImageType>(THIS->m_pProbabilitiesImage, tempImage, THIS->croppingBoundingBox.GetIndex());

   // Calulate and Show Heatmap
	 UpdateCancerHeatmap(); // This includes Calculating and rendering the heatmap

   // Display the cancer surface from the probabilities file
	THIS->m_pCancerLevelsetSurfaceActor = renderVolumeAsSurface<VolumeImageType>(THIS->m_pProbabilitiesImage, ui->qVTKWidget_Classification, false, (const float)THIS->m_LevelSetValue, 0.9, 6.0, false, true, 0.95, 0.20, 0.20);

	// Enable the corresponding control groupboxes
	ui->groupBox_CancerSurface->setChecked(true);
	ui->groupBox_HeatMap->setChecked(true);

  // Prevent User from re-opening a volume image if any of the corresponding object has been loaded
  // User should press the Clear button first
  //UpdateActionsEnabledState();

}

void ProstaCADMainWindow::UpdateCancerHeatmap()
{
     //This should never be allowed to be called unless m_pProbabilitiesImage is valid   
     if(!THIS->m_pProbabilitiesImage)
     {
       DisplayStatusMessage(statusBar(), "Error(1417-159): No probabilities volume image found ...."
              , StatusMessageHandler::/*MessageType::*/ERR );
       return;
     }
  
     // Declaring and allocating the rgb image
     RGBAVolumeType::Pointer itkrgbImage = RGBAVolumeType::New();
     itkrgbImage->CopyInformation(THIS->m_pProbabilitiesImage);
     itkrgbImage->SetRegions(THIS->m_pProbabilitiesImage->GetBufferedRegion());
     itkrgbImage->Allocate();
     
     // Filling the image     
     itk::Index<3> start = THIS->m_pProbabilitiesImage->GetBufferedRegion().GetIndex();
     itk::Size<3> size = THIS->m_pProbabilitiesImage->GetBufferedRegion().GetSize();


     //InternalPixelType maxInputValue = GetMax(THIS->m_pProbabilitiesImage); // This value will be used to rescale the input volume image

     float heatmapSpan = THIS->m_HeatMapRange - THIS->m_HeatmapMinimum;

     if(heatmapSpan < 0.08)
     {
       DisplayStatusMessage(statusBar(), "Error(1439-96): Check Probability Ranges ..."
       , StatusMessageHandler::/*MessageType::*/ERR );
       return;
     }

     for(unsigned int i = (unsigned int)start[0]; i < size[0]; i++)
     {
       for(unsigned int j = (unsigned int)start[1]; j < size[1]; j++)
       {
         for(unsigned int k = (unsigned int)start[2]; k < size[2]; k++)
         {
           itk::Index<3> idx = {{i, j, k}};
           RGBAPixelType rgbPixel;  
           rgbPixel[3] = (unsigned char)(255); // All pixels are visible by default
           InternalPixelType pixVal = THIS->m_pProbabilitiesImage->GetPixel(idx);
           if(pixVal < /*0*/THIS->m_HeatmapMinimum) // -1.0f which means it is outside the prostate
           {
             rgbPixel[0] = (unsigned char)(0);
             rgbPixel[1] = (unsigned char)(255);
             rgbPixel[2] = (unsigned char)(0);
             rgbPixel[3] = (unsigned char)(0); // invisible (transparent)
           }
           else if(pixVal < (THIS->m_HeatmapMinimum + 0.0625 * heatmapSpan))
           {
             rgbPixel[0] = (unsigned char)(0);
             rgbPixel[1] = (unsigned char)(0);
             rgbPixel[2] = (unsigned char)(131.0 + 992.0 * pixVal);
           }
           else if(pixVal < (THIS->m_HeatmapMinimum + 0.1250 * heatmapSpan))
           {
             rgbPixel[0] = (unsigned char)(0);
             rgbPixel[1] = (unsigned char)(0);
             rgbPixel[2] = (unsigned char)(131.0 + 992.0 * pixVal);
           }
           else if(pixVal < (THIS->m_HeatmapMinimum + 0.375 * heatmapSpan))
           {
             rgbPixel[0] = (unsigned char)(0);
             rgbPixel[1] = (unsigned char)(-127.5 + 1020.0 * pixVal);
             rgbPixel[2] = (unsigned char)(255);
           }
           else if(pixVal < (THIS->m_HeatmapMinimum + 0.500 * heatmapSpan))
           {
             rgbPixel[0] = (unsigned char)(-382.5 + 1020.0 * pixVal);
             rgbPixel[1] = (unsigned char)(255);
             rgbPixel[2] = (unsigned char)(637.5 - 1020.0 * pixVal);
           }
           else if(pixVal < (THIS->m_HeatmapMinimum + 0.625 * heatmapSpan))
           {
             rgbPixel[0] = (unsigned char)(-382.5 + 1020.0 * pixVal);
             rgbPixel[1] = (unsigned char)(255);
             rgbPixel[2] = (unsigned char)(637.5 - 1020.0 * pixVal);
           }
           else if(pixVal < (THIS->m_HeatmapMinimum + 0.750 * heatmapSpan))
           {
             rgbPixel[0] = (unsigned char)(255);
             rgbPixel[1] = (unsigned char)(892.5 - 1020.0 * pixVal);
             rgbPixel[2] = (unsigned char)(0);
           }
           else if(pixVal < (THIS->m_HeatmapMinimum + 0.875 * heatmapSpan))
           {
             rgbPixel[0] = (unsigned char)(255);
             rgbPixel[1] = (unsigned char)(892.5 - 1020.0 * pixVal);
             rgbPixel[2] = (unsigned char)(0);
           }
           else
           {
             rgbPixel[0] = (unsigned char)(1144.0 - 1016.0 * pixVal);
             rgbPixel[1] = (unsigned char)(0);
             rgbPixel[2] = (unsigned char)(0);
           }

           itkrgbImage->SetPixel(idx, rgbPixel);
         }
       }
     }


   THIS->m_pHeatMap = itkrgbImage;

	 //THIS->m_pHeatMap = ScalarToRGBImage<VolumeImageType, RGBVolumeType>(THIS->m_pProbabilitiesImage, THIS->m_HeatmapMinimum, THIS->m_HeatMapRange);
   // Render RGB Image
   renderVolume(ui->qVTKWidget_Classification, (RGBAVolumeConstPointer)THIS->m_pHeatMap, THIS->m_currentSlice);
   //resetControlsValues();

}

void ProstaCADMainWindow::on_action_SaveProbabilitiesVolumeImage_triggered()
{
	// Let the user select a directory where the CaP probabilities image would be saved
	// We will save the flipped (over the y-axis) copy of it so that it coincides with the original volume when open by an external program like paraview or CaPView
	ccipd::WriteITKImage<VolumeImageType>(FlipImage<VolumeImageType>(THIS->m_pProbabilitiesImage, 1), QFileDialog::getSaveFileName(this, "Save Probabilities Image ...", "", "Meta-Image Files (*.mha *.mhd *.vtk);;").toStdString());
}

void ProstaCADMainWindow::on_action_SaveHeatmapVolume_triggered()
{
	// Let the user select a directory to save the heatmap to 
	ccipd::WriteITKImage<RGBAVolumeType>(THIS->m_pHeatMap, QFileDialog::getSaveFileName(this, "Save Heatmap ...", "", "Meta-Image Files (*.mha *.mhd *.vtk);;").toStdString());
}

void ProstaCADMainWindow::initGUI()
{
	THIS->m_bCurrentlyInitializingGUI = true;

  // set up the user interface
  this->ui = new Ui_ProstaCADMainWindow;
  this->ui->setupUi( this );


  // Apply retrieved GUI settings

  // 0. Application Settings
  // Which Tab to Show
  ui->tabWidget_Main->setVisible(!THIS->m_bFirstTimeOperation);
  ui->tabWidget_Settings->setVisible(THIS->m_bFirstTimeOperation);

  // 0. Settings Tab 
  // Preprocessing settings
  // Bias Field Correction BFC
  ui->groupBox_Settings_BFC           ->setChecked(THIS->m_bCorrectForBiasField);  
  ui->radioButton_Cohen               ->setChecked(THIS->m_bUseCohenBFC        );
  ui->radioButton_N4BiasCorrection    ->setChecked(!THIS->m_bUseCohenBFC       ); 
  ui->doubleSpinBox_Settings_BiasSigma->setValue  (THIS->m_sigmaBFC            );

  // Standardization
  ui->groupBox_Settings_Standardization               ->setChecked(THIS->m_bStandardize              );
  ui->spinBox_Settings_RefHistogramBinsNum            ->setValue  (THIS->m_RefHistogramBinsNum       );
  ui->spinBox_Settings_RefHistogramMatchingPointsNum  ->setValue  (THIS->m_RefHistogramMatchingPtsNum);
  ui->radioButton_Settings_StandardizeFromRefHistogram->setChecked(THIS->m_bUseRefHistogram          );
  ui->radioButton_StandardizeFromVolumeImage          ->setChecked(!THIS->m_bUseRefHistogram         );
  ui->lineEdit_Settings_refHistogramPath              ->setText   (THIS->m_RefHistogramFilePath      );
  ui->lineEdit_Settings_refVolumePath                 ->setText   (THIS->m_RefVolumeImageFilePath    );

  // Cropping							  
  ui->groupBox_Settings_Crop        ->setChecked(THIS->m_bCropOriginalVolume);
  ui->radioButton_Settings_CropA    ->setChecked(THIS->m_bCropAutomatically );
  ui->radioButton_Settings_CropM    ->setChecked(!THIS->m_bCropAutomatically);
  ui->doubleSpinBox_Settings_Padding->setValue  (THIS->m_CroppingPadding    );

  // Normalization					  
  ui->groupBox_Settings_Normalize->setChecked(THIS->m_bNormalizeOriginalVolume);




  //1. Volumes Tab
  //1.a Volume Groupbox
  ui->groupBox_OriginalVolumeControls->setChecked(false);
  
  ui->groupBox_Preprocessing->setEnabled(true);
  ui->checkBox_BiasFieldCorrection->setChecked(THIS->m_bCorrectForBiasField);
  ui->doubleSpinBox_BiasSigma->setValue(THIS->m_sigmaBFC);
  ui->checkBox_CropAutomatically->setChecked((THIS->m_bCropOriginalVolume && THIS->m_bCropAutomatically));
  ui->checkBox_CropManually->setChecked(!THIS->m_bCropAutomatically);
  ui->checkBox_Normalize->setChecked((THIS->m_bCropOriginalVolume && !THIS->m_bCropAutomatically));
  ui->doubleSpinBox_Padding->setValue(THIS->m_CroppingPadding);
  ui->checkBox_ApplyStandardization->setChecked(THIS->m_bStandardize);
  ui->spinBox_RefHistogramBinsNum->setValue(THIS->m_RefHistogramBinsNum);
  ui->spinBox_RefHistogramMatchingPointsNum->setValue(THIS->m_RefHistogramMatchingPtsNum);
  ui->checkBox_Normalize->setChecked(THIS->m_bNormalizeOriginalVolume);
  ui->groupBox_Preprocessing->setEnabled(false);

  //Load Settings
  // Load Features' Names
  // Load Corresponding GroupBoxes
  // 


  hideAllFeatures();
  showFeatureGroupBoxByName(ui->comboBox_TextureFeatures->currentText());


// Signal/Slot Connections
  
  connect(ui->horizontalSlider_LevelSetValue, SIGNAL(valueChanged(int)), this, SLOT(setLevelsetValue(int)));
  connect(ui->doubleSpinBox_LevelSetValue, SIGNAL(valueChanged(double)), this, SLOT(setLevelsetValue(double)));

  connect(ui->horizontalSlider_WindowCurrentFeature, SIGNAL(valueChanged(int)), this, SLOT(setWindowColorCurrentFeature(int)));
  connect(ui->doubleSpinBox_WindowCurrentFeature, SIGNAL(valueChanged(double)), this, SLOT(setWindowColorCurrentFeature(double)));

  connect(ui->horizontalSlider_LevelCurrentFeature, SIGNAL(valueChanged(int)), this, SLOT(setLevelColorCurrentFeature(int)));
  connect(ui->doubleSpinBox_LevelCurrentFeature, SIGNAL(valueChanged(double)), this, SLOT(setLevelColorCurrentFeature(double)));


  connect(ui->horizontalSlider_WindowWidth_DCE_Features, SIGNAL(valueChanged(int)), this, SLOT(setWindowWidth_DCE_Features(int)));
  connect(ui->doubleSpinBox_WindowWidth_DCE_Features, SIGNAL(valueChanged(double)), this, SLOT(setWindowWidth_DCE_Features(double)));

  connect(ui->horizontalSlider_WindowLevel_DCE_Features, SIGNAL(valueChanged(int)), this, SLOT(setWindowLevel_DCE_Features(int)));
  connect(ui->doubleSpinBox_WindowLevel_DCE_Features, SIGNAL(valueChanged(double)), this, SLOT(setWindowLevel_DCE_Features(double)));



  connect(ui->horizontalSlider_WindowWidth_DCE, SIGNAL(valueChanged(int)), this, SLOT(setWindowWidth_DCE(int)));
  connect(ui->doubleSpinBox_WindowWidth_DCE, SIGNAL(valueChanged(double)), this, SLOT(setWindowWidth_DCE(double)));

  connect(ui->horizontalSlider_WindowLevel_DCE, SIGNAL(valueChanged(int)), this, SLOT(setWindowLevel_DCE(int)));
  connect(ui->doubleSpinBox_WindowLevel_DCE, SIGNAL(valueChanged(double)), this, SLOT(setWindowLevel_DCE(double)));
  

  connect(ui->horizontalSlider_TimePoint_DCE, SIGNAL(valueChanged(int)), this, SLOT(setTimePoint_DCE(int)));
  connect(ui->doubleSpinBox_TimePoint_DCE, SIGNAL(valueChanged(double)), this, SLOT(setTimePoint_DCE(double)));


  
  connect(ui->horizontalSlider_HeatmapMinimum, SIGNAL(sliderReleased()), this, SLOT(UpdateCancerHeatmap()));
  connect(ui->horizontalSlider_HeatmapRange, SIGNAL(sliderReleased()), this, SLOT(UpdateCancerHeatmap()));


  if (   !initializeQVTKWidget(ui->qVTKWidget_Volume) 
	    || !initializeQVTKWidget(ui->qVTKWidget_Features)
	    || !initializeQVTKWidget(ui->qVTKWidget_Classification)
	    || !initializeQVTKWidget(ui->qVTKWidget_Viewer_DCE)
	   )
  {
      DisplayStatusMessage(statusBar(), 
                           "Error(1491-93): One of the Viewers was not initialized ...",
                           StatusMessageHandler::/*MessageType::*/ERR );
  }

  THIS->m_bCurrentlyInitializingGUI = false;
}
//////////////////////////////////////////////////////////////////////////

void ProstaCADMainWindow::on_checkBox_WhitenData_toggled(bool val)
{
  THIS->m_bWhitenData = val;
}

void ProstaCADMainWindow::setLevelsetValue(int value)
{
  THIS->m_LevelSetValue = value/100.0f;
  disconnect(ui->doubleSpinBox_LevelSetValue, SIGNAL(valueChanged(double)), this, SLOT(setLevelsetValue(double)));
  ui->doubleSpinBox_LevelSetValue->setValue(THIS->m_LevelSetValue);
  connect(ui->doubleSpinBox_LevelSetValue, SIGNAL(valueChanged(double)), this, SLOT(setLevelsetValue(double)));
}

void ProstaCADMainWindow::setLevelsetValue(double value)
{
  THIS->m_LevelSetValue = value;
  disconnect(ui->horizontalSlider_LevelSetValue, SIGNAL(valueChanged(int)), this, SLOT(setLevelsetValue(int)));
  ui->horizontalSlider_LevelSetValue->setValue((int)(value * 100.0));
  connect(ui->horizontalSlider_LevelSetValue, SIGNAL(valueChanged(int)), this, SLOT(setLevelsetValue(int)));
}

void ProstaCADMainWindow::hideAllFeatures()
{
  QList<QGroupBox*> groupBoxlist = this->ui->groupBox_FeatureExtraction->findChildren<QGroupBox*>();
  int groupBoxListSize = groupBoxlist.size();
  for (int i = 0; i < groupBoxListSize; i++)
  {
    groupBoxlist.at(i)->setVisible(false);
  }
}

void ProstaCADMainWindow::setWindowWidth_DCE_Features(int value)
{
	disconnect(ui->doubleSpinBox_WindowWidth_DCE_Features, SIGNAL(valueChanged(double)), this, SLOT(setWindowWidth_DCE_Features(double)));
	double newVal = (double)(ui->doubleSpinBox_WindowWidth_DCE_Features->minimum() + (((double)value) * (ui->doubleSpinBox_WindowWidth_DCE_Features->maximum() - ui->doubleSpinBox_WindowWidth_DCE_Features->minimum()) / (100.0f)));
	ui->doubleSpinBox_WindowWidth_DCE_Features->setValue(newVal);
	UpdateVTKImageWindow(THIS->m_ImageProp_DCE_Features , newVal);
	ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
	connect(ui->doubleSpinBox_WindowWidth_DCE_Features, SIGNAL(valueChanged(double)), this, SLOT(setWindowWidth_DCE_Features(double)));
}

void ProstaCADMainWindow::setWindowWidth_DCE_Features(double value)
{
	disconnect(ui->horizontalSlider_WindowWidth_DCE_Features, SIGNAL(valueChanged(int)), this, SLOT(setWindowWidth_DCE_Features(int)));
	int newVal = (int)(100.00f * (value - ui->doubleSpinBox_WindowWidth_DCE_Features->minimum()) / (ui->doubleSpinBox_WindowWidth_DCE_Features->maximum() - ui->doubleSpinBox_WindowWidth_DCE_Features->minimum()));
	ui->horizontalSlider_WindowWidth_DCE_Features->setValue(newVal);
	UpdateVTKImageWindow(THIS->m_ImageProp_DCE_Features, value);
	ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
	connect(ui->horizontalSlider_WindowWidth_DCE_Features, SIGNAL(valueChanged(int)), this, SLOT(setWindowWidth_DCE_Features(int)));
}

void ProstaCADMainWindow::setWindowLevel_DCE_Features(int value)
{
	disconnect(ui->doubleSpinBox_WindowLevel_DCE_Features, SIGNAL(valueChanged(double)), this, SLOT(setWindowLevel_DCE_Features(double)));
	double newVal = (double)(ui->doubleSpinBox_WindowLevel_DCE_Features->minimum() + (((double)value) * (ui->doubleSpinBox_WindowLevel_DCE_Features->maximum() - ui->doubleSpinBox_WindowLevel_DCE_Features->minimum()) / (100.0f)));
	ui->doubleSpinBox_WindowLevel_DCE_Features->setValue(newVal);
	UpdateVTKImageLevel(THIS->m_ImageProp_DCE_Features, newVal);
	ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
	connect(ui->doubleSpinBox_WindowLevel_DCE_Features, SIGNAL(valueChanged(double)), this, SLOT(setWindowLevel_DCE_Features(double)));
}

void ProstaCADMainWindow::setWindowLevel_DCE_Features(double value)
{
	disconnect(ui->horizontalSlider_WindowLevel_DCE_Features, SIGNAL(valueChanged(int)), this, SLOT(setWindowLevel_DCE_Features(int)));
	int newVal = (int)(100.00f * (value - ui->doubleSpinBox_WindowLevel_DCE_Features->minimum()) / (ui->doubleSpinBox_WindowLevel_DCE_Features->maximum() - ui->doubleSpinBox_WindowLevel_DCE_Features->minimum()));
	ui->horizontalSlider_WindowLevel_DCE_Features->setValue(newVal);
	UpdateVTKImageLevel(THIS->m_ImageProp_DCE_Features, value);
	ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
	connect(ui->horizontalSlider_WindowLevel_DCE_Features, SIGNAL(valueChanged(int)), this, SLOT(setWindowLevel_DCE_Features(int)));
}

void ProstaCADMainWindow::setWindowWidth_DCE(int value)
{
	disconnect(ui->doubleSpinBox_WindowWidth_DCE, SIGNAL(valueChanged(double)), this, SLOT(setWindowWidth_DCE(double)));
	double newVal = (double)(ui->doubleSpinBox_WindowWidth_DCE->minimum() + (((double)value) * (ui->doubleSpinBox_WindowWidth_DCE->maximum() - ui->doubleSpinBox_WindowWidth_DCE->minimum()) / (100.0f)));
	ui->doubleSpinBox_WindowWidth_DCE->setValue(newVal);
	UpdateVTKImageWindow(THIS->m_ImageProp_DCE , newVal);
	ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
	connect(ui->doubleSpinBox_WindowWidth_DCE, SIGNAL(valueChanged(double)), this, SLOT(setWindowWidth_DCE(double)));
}

void ProstaCADMainWindow::setWindowWidth_DCE(double value)
{
	disconnect(ui->horizontalSlider_WindowWidth_DCE, SIGNAL(valueChanged(int)), this, SLOT(setWindowWidth_DCE(int)));
	int newVal = (int)(100.00f * (value - ui->doubleSpinBox_WindowWidth_DCE->minimum()) / (ui->doubleSpinBox_WindowWidth_DCE->maximum() - ui->doubleSpinBox_WindowWidth_DCE->minimum()));
	ui->horizontalSlider_WindowWidth_DCE->setValue(newVal);
	UpdateVTKImageWindow(THIS->m_ImageProp_DCE, value);
	ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
	connect(ui->horizontalSlider_WindowWidth_DCE, SIGNAL(valueChanged(int)), this, SLOT(setWindowWidth_DCE(int)));
}

void ProstaCADMainWindow::setWindowLevel_DCE(int value)
{
	disconnect(ui->doubleSpinBox_WindowLevel_DCE, SIGNAL(valueChanged(double)), this, SLOT(setWindowLevel_DCE(double)));
	double newVal = (double)(ui->doubleSpinBox_WindowLevel_DCE->minimum() + (((double)value) * (ui->doubleSpinBox_WindowLevel_DCE->maximum() - ui->doubleSpinBox_WindowLevel_DCE->minimum()) / (100.0f)));
	ui->doubleSpinBox_WindowLevel_DCE->setValue(newVal);
	UpdateVTKImageLevel(THIS->m_ImageProp_DCE, newVal);
	ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
	connect(ui->doubleSpinBox_WindowLevel_DCE, SIGNAL(valueChanged(double)), this, SLOT(setWindowLevel_DCE(double)));
}

void ProstaCADMainWindow::setWindowLevel_DCE(double value)
{
	disconnect(ui->horizontalSlider_WindowLevel_DCE, SIGNAL(valueChanged(int)), this, SLOT(setWindowLevel_DCE(int)));
	int newVal = (int)(100.00f * (value - ui->doubleSpinBox_WindowLevel_DCE->minimum()) / (ui->doubleSpinBox_WindowLevel_DCE->maximum() - ui->doubleSpinBox_WindowLevel_DCE->minimum()));
	ui->horizontalSlider_WindowLevel_DCE->setValue(newVal);
	UpdateVTKImageLevel(THIS->m_ImageProp_DCE, value);
	ui->qVTKWidget_Viewer_DCE->GetRenderWindow()->Render();
	connect(ui->horizontalSlider_WindowLevel_DCE, SIGNAL(valueChanged(int)), this, SLOT(setWindowLevel_DCE(int)));
}

void ProstaCADMainWindow::setTimePoint_DCE(int value)
{
	disconnect(ui->doubleSpinBox_TimePoint_DCE, SIGNAL(valueChanged(double)), this, SLOT(setTimePoint_DCE(double)));
	THIS->m_currentTimePointIndex_DCE = value;
	double newVal = (double)value;//(ui->doubleSpinBox_TimePoint_DCE->minimum() + (((double)value) * (ui->doubleSpinBox_TimePoint_DCE->maximum() - ui->doubleSpinBox_TimePoint_DCE->minimum()) / (1.50f)));
	
	ui->doubleSpinBox_TimePoint_DCE->setValue(newVal);

	THIS->m_pCurrentDCEVolume = GetChannelByIndex<VolumeVectorType, VolumeImageType>(THIS->m_pPreprocessedVolume_DCE /*THIS->m_pVolume_DCE*/, THIS->m_currentTimePointIndex_DCE - 1);

	//THIS->m_ImageProp_DCE = NULL;
	renderVolumeAsSlices<VolumeImageType>(THIS->m_pCurrentDCEVolume, ui->qVTKWidget_Viewer_DCE, THIS->m_ImageProp_DCE, THIS->m_currentSliceNum_DCE);
	//initControlsValues(LatestDisplayedVolumeImage::DCE);

	connect(ui->doubleSpinBox_TimePoint_DCE, SIGNAL(valueChanged(double)), this, SLOT(setTimePoint_DCE(double)));
}

void ProstaCADMainWindow::setTimePoint_DCE(double value)
{
	disconnect(ui->horizontalSlider_TimePoint_DCE, SIGNAL(valueChanged(int)), this, SLOT(setTimePoint_DCE(int)));
	THIS->m_currentTimePointIndex_DCE = (int)value;//(1.50f * (value - ui->doubleSpinBox_TimePoint_DCE->minimum()) / (ui->doubleSpinBox_TimePoint_DCE->maximum() - ui->doubleSpinBox_TimePoint_DCE->minimum()));
	
	ui->horizontalSlider_TimePoint_DCE->setValue(THIS->m_currentTimePointIndex_DCE);
	
	//THIS->m_pCurrentDCEVolume = ExtractFeatureImage(THIS->m_pVolume_DCE, THIS->m_currentTimePointIndex_DCE - 1); 
	THIS->m_pCurrentDCEVolume = GetChannelByIndex<VolumeVectorType, VolumeImageType>( THIS->m_pPreprocessedVolume_DCE /*THIS->m_pVolume_DCE*/, THIS->m_currentTimePointIndex_DCE - 1);
	//THIS->m_ImageProp_DCE = NULL;
	//clearViewer(ui->qVTKWidget_Viewer_DCE);
	renderVolumeAsSlices<VolumeImageType>(THIS->m_pCurrentDCEVolume, ui->qVTKWidget_Viewer_DCE, THIS->m_ImageProp_DCE, THIS->m_currentSliceNum_DCE);
	//initControlsValues(LatestDisplayedVolumeImage::DCE);

	connect(ui->horizontalSlider_TimePoint_DCE, SIGNAL(valueChanged(int)), this, SLOT(setTimePoint_DCE(int)));
}

void ProstaCADMainWindow::setWindowColorCurrentFeature(int value)
{
	disconnect(ui->doubleSpinBox_WindowCurrentFeature, SIGNAL(valueChanged(double)), this, SLOT(setWindowColorCurrentFeature(double)));
	double newVal = (double)(ui->doubleSpinBox_WindowCurrentFeature->minimum() + (((double)value) * (ui->doubleSpinBox_WindowCurrentFeature->maximum() - ui->doubleSpinBox_WindowCurrentFeature->minimum()) / (100.0f)));
	ui->doubleSpinBox_WindowCurrentFeature->setValue(newVal);
	UpdateVTKImageWindow(THIS->m_CurrentFeatureImageProp, newVal);
	ui->qVTKWidget_Features->GetRenderWindow()->Render();
	connect(ui->doubleSpinBox_WindowCurrentFeature, SIGNAL(valueChanged(double)), this, SLOT(setWindowColorCurrentFeature(double)));
}

void ProstaCADMainWindow::setWindowColorCurrentFeature(double value)
{
	disconnect(ui->horizontalSlider_WindowCurrentFeature, SIGNAL(valueChanged(int)), this, SLOT(setWindowColorCurrentFeature(int)));
	int newVal = (int)(100.00f * (value - ui->doubleSpinBox_WindowCurrentFeature->minimum()) / (ui->doubleSpinBox_WindowCurrentFeature->maximum() - ui->doubleSpinBox_WindowCurrentFeature->minimum()));
	ui->horizontalSlider_WindowCurrentFeature->setValue(newVal);
	UpdateVTKImageWindow(THIS->m_CurrentFeatureImageProp, value);
	ui->qVTKWidget_Features->GetRenderWindow()->Render();
	connect(ui->horizontalSlider_WindowCurrentFeature, SIGNAL(valueChanged(int)), this, SLOT(setWindowColorCurrentFeature(int)));
}

void ProstaCADMainWindow::setLevelColorCurrentFeature(int value)
{
	disconnect(ui->doubleSpinBox_LevelCurrentFeature, SIGNAL(valueChanged(double)), this, SLOT(setLevelColorCurrentFeature(double)));
	double newVal = (double)(ui->doubleSpinBox_LevelCurrentFeature->minimum() + (((double)value) * (ui->doubleSpinBox_LevelCurrentFeature->maximum() - ui->doubleSpinBox_LevelCurrentFeature->minimum()) / (100.0f)));
	ui->doubleSpinBox_LevelCurrentFeature->setValue(newVal);
	UpdateVTKImageLevel(THIS->m_CurrentFeatureImageProp, newVal);
	ui->qVTKWidget_Features->GetRenderWindow()->Render();
	connect(ui->doubleSpinBox_LevelCurrentFeature, SIGNAL(valueChanged(double)), this, SLOT(setLevelColorCurrentFeature(double)));
}

void ProstaCADMainWindow::setLevelColorCurrentFeature(double value)
{
	disconnect(ui->horizontalSlider_LevelCurrentFeature, SIGNAL(valueChanged(int)), this, SLOT(setLevelColorCurrentFeature(int)));
	int newVal = (int)(100.00f * (value - ui->doubleSpinBox_WindowCurrentFeature->minimum()) / (ui->doubleSpinBox_WindowCurrentFeature->maximum() - ui->doubleSpinBox_WindowCurrentFeature->minimum()));
	ui->horizontalSlider_LevelCurrentFeature->setValue(newVal);
	UpdateVTKImageLevel(THIS->m_CurrentFeatureImageProp, value);
	ui->qVTKWidget_Features->GetRenderWindow()->Render();
	connect(ui->horizontalSlider_LevelCurrentFeature, SIGNAL(valueChanged(int)), this, SLOT(setLevelColorCurrentFeature(int)));
}
//////////////////////////////////////////////////////////////////////////
void ProstaCADMainWindow::on_horizontalSlider_HeatmapRange_valueChanged(int range)
{
  THIS->m_HeatMapRange = (range / 100.0f);
  QString rangeNum;
  ui->lineEdit_HeatmapLegendRange->setText(rangeNum.setNum(THIS->m_HeatMapRange, 'f', 2));

  if((THIS->m_HeatMapRange - THIS->m_HeatmapMinimum) < 0.08)
  {
    ui->horizontalSlider_HeatmapMinimum->setValue(range - 8);
  }

  float hmRange = THIS->m_HeatMapRange - THIS->m_HeatmapMinimum;

  ui->lineEdit_HeatmapLegend_1->setText(rangeNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 1 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_2->setText(rangeNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 2 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_3->setText(rangeNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 3 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_4->setText(rangeNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 4 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_5->setText(rangeNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 5 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_6->setText(rangeNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 6 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_7->setText(rangeNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 7 / 8), 'f', 2));

}

void ProstaCADMainWindow::on_horizontalSlider_HeatmapMinimum_valueChanged(int min)
{
  THIS->m_HeatmapMinimum = (min / 100.0f);
  QString minNum;
  ui->lineEdit_HeatmapLegendMinimum->setText(minNum.setNum(THIS->m_HeatmapMinimum, 'f', 2));

  if ((THIS->m_HeatMapRange - THIS->m_HeatmapMinimum) < 0.08)
  {
	  ui->horizontalSlider_HeatmapRange->setValue(min + 8);
  }

  float hmRange = THIS->m_HeatMapRange - THIS->m_HeatmapMinimum;

  ui->lineEdit_HeatmapLegend_1->setText(minNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 1 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_2->setText(minNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 2 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_3->setText(minNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 3 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_4->setText(minNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 4 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_5->setText(minNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 5 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_6->setText(minNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 6 / 8), 'f', 2));
  ui->lineEdit_HeatmapLegend_7->setText(minNum.setNum(THIS->m_HeatmapMinimum + (hmRange * 7 / 8), 'f', 2));

}

void ProstaCADMainWindow::on_comboBox_TextureFeatures_currentTextChanged(const QString & text)
{
  hideAllFeatures();
  showFeatureGroupBoxByName(text);
}

void ProstaCADMainWindow::showFeatureGroupBoxByName(const QString & text)
{
  QString	groupBoxFeatureName = "groupBox_" + text + "Feature";
  QList<QGroupBox*> groupBoxlist = this->findChildren<QGroupBox*>(groupBoxFeatureName);
  if (1 != groupBoxlist.size())
  {
    statusBar()->showMessage("Something Wrong Happened ...");
    return;
  }
  groupBoxlist.at(0)->setVisible(true);
}



//TODO: Add color of the surface as argument
void ProstaCADMainWindow::renderSurface(QVTKWidget* pQVTKWidget, VolumeImageConstPointer pVolume, InternalPixelType levelsetValue/* = 0.5*/)
{
  if (!pQVTKWidget || !pVolume)
  {
    statusBar()->showMessage("Error: Invalid window or volume pointer");
    return;
  }

  //if (levelsetValue < GetMin(pVolume) || levelsetValue > GetMax(pVolume))
  if (levelsetValue < 0.0f || levelsetValue > 1.0f) // Assuming only this range for speeding the process
  {
    statusBar()->showMessage("Error: Levelset out of range ...");
    return;
  }
  
  const vtkRenderWindowPointer renderWindow = pQVTKWidget->GetRenderWindow();
  const vtkRendererPointer renderer = renderWindow->GetRenderers()->GetFirstRenderer();

  levelsetValue -= std::numeric_limits< InternalPixelType >::epsilon();

  
  THIS->m_pCancerLevelsetSurfaceActor = GenerateVTKActorFromIsosurface(pVolume, levelsetValue); 
  renderer->AddActor(THIS->m_pCancerLevelsetSurfaceActor);
  
  renderer->SetBackground ( 0.0, 0.0, 0.0 );   
  renderer->ResetCamera();
  renderWindow->AddRenderer(renderer);
  renderWindow->Render();
}


void ProstaCADMainWindow::on_doubleSpinBox_LevelSetValue_valueChanged(double value)
{
  THIS->m_LevelSetValue = value;
}

void ProstaCADMainWindow::renderVolume(QVTKWidget* pQVTKWidget, VolumeImageConstPointer pVolumeImage, bool bClearViewerFirst /*= true*/, unsigned int sliceNumber /*= 0*/)
{
  if (!pQVTKWidget || !pVolumeImage)
  {
    statusBar()->showMessage("Invalid rendering parameters ...");
    return;
  }

  if (bClearViewerFirst)
  {
    clearViewer(pQVTKWidget);
  }

  const vtkRenderWindowPointer renderWindow = pQVTKWidget->GetRenderWindow();
  const vtkRendererPointer renderer = renderWindow->GetRenderers()->GetFirstRenderer();

  //Define the background color of rendering window
  renderer->SetBackground ( 0.0, 0.0, 0.0 );
  renderer->ResetCamera();

  UpdateVTKImageProp(renderWindow, THIS->m_ImageProp_T2, pVolumeImage, sliceNumber);
  //UpdateWindowLevelSliders2(pVolumeImage, ui->horizontalSlider_Window, ui->horizontalSlider_Level, ui->spinBox_Window, ui->spinBox_Level);
  //renderer->ResetCamera();
  //renderWindow->Render();
}


void ProstaCADMainWindow::renderVolume(QVTKWidget* pQVTKWidget, RGBAVolumeConstPointer pVolumeImage, unsigned int sliceNumber)
{
   if (!pQVTKWidget || !pVolumeImage)
   {
     statusBar()->showMessage("Invalid rendering parameters ...");
     return;
   }
 
   const vtkRenderWindowPointer renderWindow = pQVTKWidget->GetRenderWindow();
   
   const vtkRendererPointer renderer = renderWindow->GetRenderers()->GetFirstRenderer();
   renderer->SetBackground ( 0.0, 0.0, 0.0 );    //Define the background color of rendering window
   renderer->ResetCamera();

   UpdateVTKImageProp(renderWindow, THIS->m_HeatmapProp, pVolumeImage, sliceNumber);

}



void ProstaCADMainWindow::renderHeatMap()
{
   //if (!pVolumeImage)
   //{
   //  statusBar()->showMessage("Invalid rendering parameters ...");
   //  return;
   //}
 
   //const vtkRenderWindowPointer renderWindow = ui->->GetRenderWindow();
   //
   //const vtkRendererPointer renderer = renderWindow->GetRenderers()->GetFirstRenderer();
   //renderer->SetBackground ( 0.0, 0.0, 0.0 );    //Define the background color of rendering window
   //renderer->ResetCamera();

   //UpdateVTKImageProp(renderWindow, THIS->m_HeatmapProp, pVolumeImage, sliceNumber);

}

void ProstaCADMainWindow::initControlsValues(int latestDisplayedVolume)
{
  switch (latestDisplayedVolume)
  {
  case ORIGINAL:
	  ui->groupBox_OriginalVolumeControls->setChecked(true);
	  ui->groupBox_Preprocessing->setEnabled(true);
	  ui->groupBox_FeatureExtraction->setEnabled(true);

	  UpdateSliceSlider(THIS->m_pOriginalVolume, ui->horizontalSlider_currentSlice, ui->spinBox_currentSlice);
	  UpdateWindowLevelSliders2(THIS->m_pOriginalVolume, ui->horizontalSlider_Window, ui->horizontalSlider_Level, ui->spinBox_Window, ui->spinBox_Level);
	  UpdateTransparencySlider(THIS->m_pOriginalVolume, ui->horizontalSlider_InputVolumeImageOpacity, ui->spinBox_Transparency);
	  break;

  case DCE:
	  ui->groupBox_DCEVolumeControls->setChecked(true);
	  ui->groupBox_DCEFeaturesControls->setEnabled(true);

	  //UpdateSliceTimePointSlider(THIS->m_pVolume_DCE, ui->horizontalSlider_TimePoint_DCE, ui->doubleSpinBox_TimePoint_DCE);
	  UpdateSliceNumberSlider(THIS->m_pCurrentDCEVolume, ui->horizontalSlider_SliceNum_DCE, ui->spinBox_SliceNum_DCE);
	  UpdateWindowLevelSliders2(THIS->m_pCurrentDCEVolume, ui->horizontalSlider_WindowWidth_DCE, ui->horizontalSlider_WindowLevel_DCE, ui->doubleSpinBox_WindowWidth_DCE, ui->doubleSpinBox_WindowLevel_DCE);
	  UpdateTransparencySlider(THIS->m_pCurrentDCEVolume, ui->horizontalSlider_Opacity_DCE, ui->spinBox_Opacity_DCE);
	  
    //Update Wheels
    
    
    break;

  case DCEFEATURE:
	  ui->groupBox_DCEFeaturesControls->setChecked(true);

	  UpdateSliceNumberSlider(THIS->m_pCurrentDCEFeature, ui->horizontalSlider_SliceNum_DCE_Features, ui->spinBox_SliceNum_DCE_Features);
	  UpdateWindowLevelSliders2(THIS->m_pCurrentDCEFeature, ui->horizontalSlider_WindowWidth_DCE_Features, ui->horizontalSlider_WindowLevel_DCE_Features, ui->doubleSpinBox_WindowWidth_DCE_Features, ui->doubleSpinBox_WindowLevel_DCE_Features);
	  UpdateTransparencySlider(THIS->m_pCurrentDCEFeature, ui->horizontalSlider_Opacity_DCE_Features, ui->spinBox_Opacity_DCE_Features);
	  break;

  case PREPROCESSED:
	  ui->groupBox_PreprocessedVolumeControls->setChecked(true);

	  UpdateSliceSlider(THIS->m_pPreprocessedVolume, ui->horizontalSlider_currentSlicePreprocessed, ui->spinBox_currentSlicePreprocessed);
	  UpdateWindowLevelSliders2(THIS->m_pPreprocessedVolume, ui->horizontalSlider_WindowPreprocessed, ui->horizontalSlider_LevelPreprocessed, ui->spinBox_WindowPreprocessed, ui->spinBox_LevelPreprocessed);
	  UpdateTransparencySlider(THIS->m_pPreprocessedVolume, ui->horizontalSlider_OpacityPreprocessed, ui->spinBox_OpacityPreprocessed);
	  break;

  case FEATURE:
	  UpdateSliceSlider(THIS->m_pCurrentFeatureVolume, ui->horizontalSlider_currentSliceCurrentFeature, ui->spinBox_currentSliceCurrentFeature);
	  UpdateWindowLevelSliders2(THIS->m_pCurrentFeatureVolume, ui->horizontalSlider_WindowCurrentFeature, ui->horizontalSlider_LevelCurrentFeature, ui->doubleSpinBox_WindowCurrentFeature, ui->doubleSpinBox_LevelCurrentFeature);
	  UpdateTransparencySlider(THIS->m_pCurrentFeatureVolume, ui->horizontalSlider_OpacityCurrentFeature, ui->spinBox_OpacityCurrentFeature);
	  break;
  }

}

void ProstaCADMainWindow::resetControlsValues()
{
  ui->horizontalSlider_Window->setValue(1);
  ui->horizontalSlider_Level->setValue(1);
  ui->horizontalSlider_InputVolumeImageOpacity->setValue(100);
}

// this captures all events occurring on the dialog
bool ProstaCADMainWindow::eventFilter( QObject * object, QEvent * event )
{
  if (object == ui->qVTKWidget_Volume && event->type() == QEvent::MouseButtonDblClick)
  {
    QMouseEvent * mouseEvent = static_cast<QMouseEvent*>(event);
    if (mouseEvent->button() == Qt::LeftButton) 
    {
      // Get the coordinates of the mouse 

      // Render the landmark


    }
 
  } // object & event type

  return false;

} // eventFilter


void ProstaCADMainWindow::on_groupBox_CancerSurface_toggled(bool showLevelsetSurface)
{
  if (!THIS->m_pCancerLevelsetSurfaceActor)
  {
    ui->groupBox_CancerSurface->setChecked(false);
    statusBar()->showMessage("Warning(1992-44): No Surface calculated ...");
    return;
  }
  THIS->m_pCancerLevelsetSurfaceActor->SetVisibility(showLevelsetSurface);
  ui->qVTKWidget_Classification->GetRenderWindow()->Render();

  ui->action_SetCancerSurfaceColor->setEnabled(showLevelsetSurface);
}

void ProstaCADMainWindow::on_groupBox_HeatMap_toggled(bool showHeatmap)
{
	if (!THIS->m_HeatmapProp)
	{
		ui->groupBox_HeatMap->setChecked(false);
		statusBar()->showMessage("Warning: No Heatmap calculated ...");
		return;
	}
	THIS->m_HeatmapProp->SetVisibility(showHeatmap);
	ui->qVTKWidget_Classification->GetRenderWindow()->Render();
}

void ProstaCADMainWindow::on_pushButton_Train_clicked()
{
  //// Load Datasets, ProstateMasks, Labels
  //QSettings settings("J:\\CODE\\CCIPD\\build_trunk\\MSVS2012x64\\GUI\\Debug\\TrainingSet_1.ini", QSettings::IniFormat);
  //settings.beginGroup("Dadatsets");
  //QStringList player_number = settings.childGroups(); // returns 0, 1, 2 - OK !
  //const QStringList childKeys = settings.childKeys(); // should return name, wins, ... right ?
  //foreach(const QString &childKey, childKeys)
  //{
  //    //ui->choosePlayerBox->addItem(settings->value(childKey).toString());  // should add lukasz, 3, 3, pawel...., but it doesn`t work
  //     QString jj = settings.value(childKey).toString();
  //     cout << jj.toStdString() << endl;
  //}
  //settings.endGroup();

///////PREPARE FOR TRAINING/////////////////////////////
  
	// 1. Get A directory where volumes lie (all are 1 file/volume)


	// 2. Load All Volumes Available


	// 3. Preprocess All loaded volumes

	// a. Bias Field, b. Crop, c. Standardize


	// 4. Load a set of provisional features (100)

	// 5. Extract Features

	// 6. Prepare for Classification
	// a. segment (load prostate masks), b. whiten data, reshape to matrix


	// 7. Train

	// Classify

	// Validate
}

void ProstaCADMainWindow::on_pushButton_CancelNewSettings_clicked()
{
	ui->tabWidget_Main->setVisible(true);
	ui->tabWidget_Settings->setVisible(false);
}

void ProstaCADMainWindow::on_pushButton_SaveNewSettings_clicked()
{
	UpdateSettings();
	ui->tabWidget_Main->setVisible(true);
	ui->tabWidget_Settings->setVisible(false);
}

void ProstaCADMainWindow::UpdateSettings()
{
	// Application Settings
	THIS->m_bFirstTimeOperation = false;


	// Preprocessing settings
	// Bias Field Correction BFC
	THIS->m_bCorrectForBiasField        = ui->groupBox_Settings_BFC->isChecked();  
	THIS->m_bUseCohenBFC                = ui->radioButton_Cohen->isChecked(); 
	THIS->m_sigmaBFC                    = ui->doubleSpinBox_Settings_BiasSigma->value();

	// Standardization
	THIS->m_bStandardize                = ui->groupBox_Settings_Standardization->isChecked();
	THIS->m_RefHistogramBinsNum         = ui->spinBox_Settings_RefHistogramBinsNum->value();
	THIS->m_RefHistogramMatchingPtsNum  = ui->spinBox_Settings_RefHistogramMatchingPointsNum->value();
	THIS->m_bUseRefHistogram            = ui->radioButton_Settings_StandardizeFromRefHistogram->isChecked();
	THIS->m_RefHistogramFilePath        = ui->lineEdit_Settings_refHistogramPath->text();
	THIS->m_RefVolumeImageFilePath      = ui->lineEdit_Settings_refVolumePath->text();
										  
	// Cropping							  
	THIS->m_bCropOriginalVolume         = ui->groupBox_Settings_Crop->isChecked();
	THIS->m_bCropAutomatically          = ui->radioButton_Settings_CropA->isChecked();
	THIS->m_CroppingPadding             = ui->doubleSpinBox_Settings_Padding->value();
										 
	// Normalization					  
	THIS->m_bNormalizeOriginalVolume    = ui->groupBox_Settings_Normalize->isChecked();

	SaveSettings();
}

void ProstaCADMainWindow::on_action_showSettingsTab_triggered()
{
	//ui->tabWidget_Main->currentWidget()->setVisible(false);
	ui->tabWidget_Main->setVisible(false);
	ui->tabWidget_Settings->setVisible(true);
}

void ProstaCADMainWindow::on_action_showOptionsTab_triggered()
{

}

void ProstaCADMainWindow::on_checkBox_BiasFieldCorrection_toggled(bool correctBF)
{
	THIS->m_bCorrectForBiasField = correctBF;
}

void ProstaCADMainWindow::on_checkBox_CropManually_toggled(bool cropM)
{
	if(cropM && !THIS->m_bCurrentlyInitializingGUI) 
	{
		if (!THIS->m_pOriginalVolume)  // No Original volume loaded yet
		{
			on_action_LoadVolumeImage_triggered();

			if (!THIS->m_pOriginalVolume)  // double-check
			{
				statusBar()->showMessage("Warning(2060-43): No Volume Image was loaded, Manual Cropping will be disabled ...");
				ui->checkBox_CropManually->setChecked(false);
				return;
			}
		}

		if (0 == THIS->croppingBoundingBox.GetSize(0)) // No bounding box loaded before
		{
			LandmarkSetPointer pLandmarks = PickPointsOnImage((VolumeImageConstPointer)THIS->m_pOriginalVolume);
			if (!pLandmarks) // User pressed Cancel
			{
				return;
			}
			
			const auto numberOfPoints = pLandmarks->GetNumberOfPoints();
			if ( numberOfPoints < 4 )
			{
               DisplayStatusMessage(  statusBar()
				                    , "Error(2030-41): At least four points should be provided in order to create a bounding box ..."
                                    , StatusMessageHandler::ERR );
				ui->checkBox_CropManually->setChecked(false);
				return;
			}

			// CreateBoundingBox2: Takes landmark point from user on one slice and extends the box through all slices
			//  const VolumeRegionType boundingBox = CreateBoundingBox2(*pLandmarks, *THIS->m_pOriginalVolume );
			THIS->croppingBoundingBox = CreateBoundingBox(*pLandmarks, *THIS->m_pOriginalVolume);

			// If there is no depth (Number of slices) for the calculated bounding box, then no bounding box was calculated
			// This will only be because the transformation from physical point to index is missing
			if (0 == THIS->croppingBoundingBox.GetSize()[2])
			{
               DisplayStatusMessage(  statusBar()
				                    , "Error(765-50): Failed to get indexes of picked points in order to create a bounding box ..."
                                    , StatusMessageHandler::ERR );

				ui->checkBox_CropManually->setChecked(false);
				return;
			}

			THIS->m_pPreprocessedVolume = CropVolume(THIS->m_pOriginalVolume, THIS->croppingBoundingBox);

			// BUG: TODO: mask should be cropped too


		}

		ui->checkBox_CropAutomatically->setChecked(false);

	}

	THIS->m_bCropAutomatically = ui->checkBox_CropAutomatically->isChecked();
}

void ProstaCADMainWindow::on_checkBox_CropAutomatically_toggled(bool cropA)
{
	if(cropA && !THIS->m_bCurrentlyInitializingGUI)
	{
		if (!THIS->m_pProstateMask)  // No prostate mask loaded before
		{
			on_action_Load_Mask_Prostate_triggered();

			if (!THIS->m_pProstateMask)  // No prostate mask loaded before
			{
				statusBar()->showMessage("Warning(2094-55): No Prostate Mask was loaded, Cropping will be disabled ...");
				ui->checkBox_CropAutomatically->setChecked(false);
				return;
			}
		}

		ui->checkBox_CropManually->setChecked(false);
	}

	THIS->m_bCropAutomatically = ui->checkBox_CropAutomatically->isChecked();
}

void ProstaCADMainWindow::on_checkBox_ApplyStandardization_toggled(bool standardize)
{
	if (standardize && !THIS->m_bCurrentlyInitializingGUI)
	{
		if (!THIS->m_pReferenceHistogram && !THIS->m_pRefVolume)
		{
			if (THIS->m_bUseRefHistogram)
			{
				on_actionFile_Load_StandardImage_triggered();
			}
			else
			{
				on_actionFile_Load_StandardImage_triggered();
			}

			if (!THIS->m_pReferenceHistogram && !THIS->m_pRefVolume)
			{

				statusBar()->showMessage("Warning(2094-55): No Standardization Reference was loaded, Standardization will not be enabled ...");
				ui->checkBox_ApplyStandardization->setChecked(false);
			}
		}

	}

	THIS->m_bStandardize = ui->checkBox_ApplyStandardization->isChecked();

}

void ProstaCADMainWindow::on_checkBox_Normalize_toggled(bool normalize)
{
	THIS->m_bNormalizeOriginalVolume = normalize;
}

void ProstaCADMainWindow::on_doubleSpinBox_BiasSigma_valueChanged(double val)
{
	THIS->m_sigmaBFC = val;
}

void ProstaCADMainWindow::on_doubleSpinBox_Padding_valueChanged(double val)
{
	THIS->m_CroppingPadding = val;
}

void ProstaCADMainWindow::on_spinBox_RefHistogramBinsNum_valueChanged(int val)
{
	THIS->m_RefHistogramBinsNum = val;
}

void ProstaCADMainWindow::on_spinBox_RefHistogramMatchingPointsNum_valueChanged(int val)
{
	THIS->m_RefHistogramMatchingPtsNum = val;
}

void ProstaCADMainWindow::on_actionAbout_ProstaCAD_triggered()
{
	QMessageBox::about( this, tr( "About ProstaCAD" ),
		tr( "ProstaCAD is a C++ toolkit for 3D visualization, manipulation and detection of Prostate Cancer.\n\
			\n\
			This is an in-house version which is distributed AS IS.\n\
			Copyright (c) CCIPD and/or its subsidiary(-ies) and other contributors.\n\
			This program uses the toolkits: ITK, VTK, Qt, Boost, Eigen.\n\
			Author: Ahmad Algohary" ) );
}

void ProstaCADMainWindow::on_actionAbout_CCIPD_triggered()
{
	QMessageBox::about( this, tr( "About CCIPD" ),
		tr( "The Center of Computational Imaging and Personalized Diagnostics at Case Western Reserve University is involved in various different aspects of developing, evaluating and applying novel quantitative image analysis, computer vision, signal processing, segmentation, multi-modal co-registration tools, pattern recognition, and machine learning tools for disease diagnosis, prognosis, and theragnosis in the context of breast, prostate, head and neck, and brain tumors as also epilepsy and carotid plaque. Our group is also exploring the utility of these methods in studying correlations of disease markers across multiple scales, modalities, and functionalities -- from gene and protein expression to spectroscopy to digital pathology and to multi-parametric MRI.\n\
			\n\
			\n\
			For more information, please visit ccipd.case.edu" ) );
}




void ProstaCADMainWindow::on_action_SavePreprocessedVolume_triggered()
{
	if (!THIS->m_pPreprocessedVolume)
	{
		statusBar()->showMessage("Warning(2174-563): There is no valid Preprocessed volume image to save ...");
		return;
	}
	
	QString imagePath = QFileDialog::getSaveFileName(this, "Save Preprocessed Volume Image ...", "", "Meta-Image Files (*.mha *.mhd *.vtk);;");
	if (imagePath.isEmpty())
	{
		// write a warning on the status bar
		statusBar()->showMessage("Warning(2180-48): Empty or invalid File Path ....");
		return;
	}

	ccipd::WriteITKImage<VolumeImageType>(THIS->m_pPreprocessedVolume, imagePath.toStdString());

}

void ProstaCADMainWindow::on_action_SaveHistogramOriginalVolume_triggered()
{

}

void ProstaCADMainWindow::on_action_SaveHistogramPreprocessedVolume_triggered()
{
  /*HistogramTypeD **/HistogramDPointer pSourceHistogram = Get1DHistogram(THIS->m_pPreprocessedVolume /*, binNumber*/ );
////////////////////
  WriteHistogram<HistogramTypeD>(pSourceHistogram, /*
  
    QString FilePath = */QFileDialog::getSaveFileName(this,
    tr("Please, select a file name to save the histogram to ...."), ""/*THIS->m_lastOriginalVolumePath*/, tr("Histogram Files (*.csv)")).toStdString()
        );
}

void ProstaCADMainWindow::on_action_SaveHistogramStandardVolume_triggered()
{

    /*HistogramTypeD **/HistogramDPointer pSourceHistogram = Get1DHistogram(THIS->m_pRefVolume, 100 /*binNumber*/ );
////////////////////
  WriteHistogram<HistogramTypeD>(pSourceHistogram, /*
  
    QString FilePath = */QFileDialog::getSaveFileName(this,
    tr("Please, select a file name to save the histogram to ...."), ""/*THIS->m_lastOriginalVolumePath*/, tr("Histogram Files (*.csv)")).toStdString()
        );

}

void ProstaCADMainWindow::on_action_SetCancerSurfaceColor_triggered()
{
	UpdateVTKPropColorGUI(THIS->m_pCancerLevelsetSurfaceActor);
	ui->qVTKWidget_Classification->GetRenderWindow()->Render();
}

void ProstaCADMainWindow::on_action_SetProstateSurfaceColor_triggered()
{
	UpdateVTKPropColorGUI(THIS->m_pProstateLevelsetSurfaceActor);
	ui->qVTKWidget_Classification->GetRenderWindow()->Render();
}

void ProstaCADMainWindow::on_action_SetPZSurfaceColor_triggered()
{
	UpdateVTKPropColorGUI(THIS->m_pPZLevelsetSurfaceActor);
	ui->qVTKWidget_Classification->GetRenderWindow()->Render();
}

void ProstaCADMainWindow::on_action_SetCGSurfaceColor_triggered()
{
	UpdateVTKPropColorGUI(THIS->m_pCGLevelsetSurfaceActor);
	ui->qVTKWidget_Classification->GetRenderWindow()->Render();
}

//////////////////////////////////////////////////////////////////////////////////////////
 void ProstaCADMainWindow::ResetApp()
 {
   // Reset GUI
   clearViewer(ui->qVTKWidget_Volume);
   clearViewer(ui->qVTKWidget_Features);
   clearViewer(ui->qVTKWidget_Classification);
   clearViewer(ui->qVTKWidget_Viewer_DCE);

   ui->action_LoadVolumeImage->setEnabled(true);
   ui->action_Load_Mask_Prostate->setEnabled(true);
   //ui->action_Load_Probabilities->setEnabled(true);

   ui->groupBox_ProstateMask->setChecked(false);
   ui->groupBox_HeatMap->setChecked(false);
   ui->groupBox_CancerSurface->setChecked(false);
   ui->groupBox_OriginalVolumeControls->setChecked(false);
//////////////////////////////////////////////////////

   // Reset Secret Data Objects
   THIS->m_pOriginalVolume     = NULL;
   
   THIS->m_pProstateMask       = NULL;
   
   
   THIS->m_pPZMask             = NULL;
   THIS->m_pCGMask             = NULL;
   THIS->m_pProbabilitiesImage = NULL; 
   
      
   THIS->m_pHeatMap = NULL;

   // For Volumes as Slices
   THIS->m_ImageProp_T2 = NULL;	
   THIS->m_ImageProp_DCE = NULL;	
   THIS->m_ImageProp_DCE_Features = NULL;

   THIS->m_ProstateMaskProp  = NULL;
   THIS->m_PZMaskProp        = NULL;
   THIS->m_CGMaskProp        = NULL;
   THIS->m_HeatmapProp       = NULL;


   // For Surfaces
	 THIS->m_pProstateLevelsetSurfaceActor = NULL;
   THIS->m_pPZLevelsetSurfaceActor       = NULL;
   THIS->m_pCGLevelsetSurfaceActor       = NULL;
   THIS->m_pCancerLevelsetSurfaceActor   = NULL;

   // For default values
   // slice num
   // opacity and so



 }
//////////////////////////////////////////////////////////////////////////////////////////
void ProstaCADMainWindow::clearViewer(QVTKWidget* pQVTKWidget)
{
  if (!pQVTKWidget) 
  {
    statusBar()->showMessage("Invalid QVTKWidget pointer ...");
    return;
  }

  // extract the render window
  const vtkRenderWindowPointer renderWindow = pQVTKWidget->GetRenderWindow();
  if (!renderWindow) 
  {
    statusBar()->showMessage("Invalid Render Window");
    return;
  }

  // clear the render window
  const vtkRendererPointer renderer = renderWindow->GetRenderers()->GetFirstRenderer();
  if (!renderer) 
  {
    statusBar()->showMessage("Invalid Renderer ...");
    return;
  }
  renderer->RemoveAllViewProps();

  renderWindow->Render();  
  renderWindow->Render();
}

void ProstaCADMainWindow::on_pushButton_test_clicked()
{
  DisplayStatusMessage(statusBar(), "Error" , StatusMessageHandler::SUCCESS);
}

void ProstaCADMainWindow::UpdateStatusMessage(const QString & msg)
{
  statusBar()->showMessage(msg);
  statusBar()->setStyleSheet(msg);
}

void ProstaCADMainWindow::on_qwtWheel_CropX_DCE_valueChanged(double value)
{ 

  THIS->m_cropSize_DCE.SetElement(0, (VolumeVectorType::SizeValueType)value);

  THIS->m_pPreprocessedVolume_DCE = CropVolumeImage<VolumeVectorType>(THIS->m_pVolume_DCE, THIS->m_cropSize_DCE);
  
  // Now Display a slice of the cropped volume 
  THIS->m_pCurrentDCEVolume = ExtractFeatureImage(THIS->m_pPreprocessedVolume_DCE, THIS->m_currentTimePointIndex_DCE); 
  renderVolumeAsSlices<VolumeImageType>(THIS->m_pCurrentDCEVolume, ui->qVTKWidget_Viewer_DCE, THIS->m_ImageProp_DCE, THIS->m_currentSliceNum_DCE);
  UpdateSliceTimePointSlider(THIS->m_pPreprocessedVolume_DCE, ui->horizontalSlider_TimePoint_DCE, ui->doubleSpinBox_TimePoint_DCE);
  //initControlsValues(LatestDisplayedVolumeImage::DCE);

}

void ProstaCADMainWindow::on_qwtWheel_CropY_DCE_valueChanged(double value)
{ 
  THIS->m_cropSize_DCE.SetElement(1, (VolumeVectorType::SizeValueType)value);
 
  THIS->m_pPreprocessedVolume_DCE = CropVolumeImage<VolumeVectorType>(THIS->m_pVolume_DCE, THIS->m_cropSize_DCE);
  
  // Now Display a slice of the cropped volume 
  THIS->m_pCurrentDCEVolume = ExtractFeatureImage(THIS->m_pPreprocessedVolume_DCE, THIS->m_currentTimePointIndex_DCE); 
  renderVolumeAsSlices<VolumeImageType>(THIS->m_pCurrentDCEVolume, ui->qVTKWidget_Viewer_DCE, THIS->m_ImageProp_DCE, THIS->m_currentSliceNum_DCE);
  UpdateSliceTimePointSlider(THIS->m_pPreprocessedVolume_DCE, ui->horizontalSlider_TimePoint_DCE, ui->doubleSpinBox_TimePoint_DCE);
  //initControlsValues(LatestDisplayedVolumeImage::DCE);

}

void ProstaCADMainWindow::on_pushButton_SaveCurrentTimePoint_DCE_clicked()
{
  QString imagePath = QFileDialog::getSaveFileName(this, "Save Preprocessed Volume Image ...", 
                                   "", "Meta-Image Files (*.mha *.mhd *.vtk);;");
	if (imagePath.isEmpty())
	{
		// write a warning on the status bar
		statusBar()->showMessage("Warning(2180-418): Empty or invalid File Path ....");
		return;
	}

	ccipd::WriteITKImage<VolumeImageType>(GetChannelByIndex<VolumeVectorType, VolumeImageType>(
                       THIS->m_pPreprocessedVolume_DCE /*THIS->m_pVolume_DCE*/, 
                       THIS->m_currentTimePointIndex_DCE - 1), imagePath.toStdString());
     
}

void ProstaCADMainWindow::on_pushButton_SaveAllTimePoints_DCE_clicked()
{
    // Let the user select a directory to save to 
    QString dirPath = QFileDialog::getExistingDirectory(this, 
		tr( "Please, select a directory to save the DCE volume time points to ...."), 
		THIS->m_lastVolumePath_DCE);

    // Check the returned directory path
    if (dirPath.isEmpty())
    {
      // write a warning on the status bar
      statusBar()->showMessage("Warning(826-417): Empty or invalid directory ....");
      return;
    }
     
    
    for(unsigned int i = 0; i < THIS->m_pPreprocessedVolume_DCE->GetVectorLength(); i++)
    {
      QString current; 
      WriteITKImage<VolumeImageType>(GetChannelByIndex<VolumeVectorType, VolumeImageType>(
                       THIS->m_pPreprocessedVolume_DCE /*THIS->m_pVolume_DCE*/, i),
                       dirPath.toStdString() + "/" + "DCE_" + current.setNum(i).toStdString() + ".vtk");
    }

}



} // namespace ccipd
